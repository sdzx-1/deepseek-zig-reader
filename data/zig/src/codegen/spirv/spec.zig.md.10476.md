```zig
pub const Opcode = enum(u16) {
    OpNop = 0,
    OpUndef = 1,
    OpSourceContinued = 2,
    OpSource = 3,
    OpSourceExtension = 4,
    OpName = 5,
    OpMemberName = 6,
    OpString = 7,
    OpLine = 8,
    OpExtension = 10,
    OpExtInstImport = 11,
    OpExtInst = 12,
    OpMemoryModel = 14,
    OpEntryPoint = 15,
    OpExecutionMode = 16,
    OpCapability = 17,
    OpTypeVoid = 19,
    OpTypeBool = 20,
    OpTypeInt = 21,
    OpTypeFloat = 22,
    OpTypeVector = 23,
    OpTypeMatrix = 24,
    OpTypeImage = 25,
    OpTypeSampler = 26,
    OpTypeSampledImage = 27,
    OpTypeArray = 28,
    OpTypeRuntimeArray = 29,
    OpTypeStruct = 30,
    OpTypeOpaque = 31,
    OpTypePointer = 32,
    OpTypeFunction = 33,
    OpTypeEvent = 34,
    OpTypeDeviceEvent = 35,
    OpTypeReserveId = 36,
    OpTypeQueue = 37,
    OpTypePipe = 38,
    OpTypeForwardPointer = 39,
    OpConstantTrue = 41,
    OpConstantFalse = 42,
    OpConstant = 43,
    OpConstantComposite = 44,
    OpConstantSampler = 45,
    OpConstantNull = 46,
    OpSpecConstantTrue = 48,
    OpSpecConstantFalse = 49,
    OpSpecConstant = 50,
    OpSpecConstantComposite = 51,
    OpSpecConstantOp = 52,
    OpFunction = 54,
    OpFunctionParameter = 55,
    OpFunctionEnd = 56,
    OpFunctionCall = 57,
    OpVariable = 59,
    OpImageTexelPointer = 60,
    OpLoad = 61,
    OpStore = 62,
    OpCopyMemory = 63,
    OpCopyMemorySized = 64,
    OpAccessChain = 65,
    OpInBoundsAccessChain = 66,
    OpPtrAccessChain = 67,
    OpArrayLength = 68,
    OpGenericPtrMemSemantics = 69,
    OpInBoundsPtrAccessChain = 70,
    OpDecorate = 71,
    OpMemberDecorate = 72,
    OpDecorationGroup = 73,
    OpGroupDecorate = 74,
    OpGroupMemberDecorate = 75,
    OpVectorExtractDynamic = 77,
    OpVectorInsertDynamic = 78,
    OpVectorShuffle = 79,
    OpCompositeConstruct = 80,
    OpCompositeExtract = 81,
    OpCompositeInsert = 82,
    OpCopyObject = 83,
    OpTranspose = 84,
    OpSampledImage = 86,
    OpImageSampleImplicitLod = 87,
    OpImageSampleExplicitLod = 88,
    OpImageSampleDrefImplicitLod = 89,
    OpImageSampleDrefExplicitLod = 90,
    OpImageSampleProjImplicitLod = 91,
    OpImageSampleProjExplicitLod = 92,
    OpImageSampleProjDrefImplicitLod = 93,
    OpImageSampleProjDrefExplicitLod = 94,
    OpImageFetch = 95,
    OpImageGather = 96,
    OpImageDrefGather = 97,
    OpImageRead = 98,
    OpImageWrite = 99,
    OpImage = 100,
    OpImageQueryFormat = 101,
    OpImageQueryOrder = 102,
    OpImageQuerySizeLod = 103,
    OpImageQuerySize = 104,
    OpImageQueryLod = 105,
    OpImageQueryLevels = 106,
    OpImageQuerySamples = 107,
    OpConvertFToU = 109,
    OpConvertFToS = 110,
    OpConvertSToF = 111,
    OpConvertUToF = 112,
    OpUConvert = 113,
    OpSConvert = 114,
    OpFConvert = 115,
    OpQuantizeToF16 = 116,
    OpConvertPtrToU = 117,
    OpSatConvertSToU = 118,
    OpSatConvertUToS = 119,
    OpConvertUToPtr = 120,
    OpPtrCastToGeneric = 121,
    OpGenericCastToPtr = 122,
    OpGenericCastToPtrExplicit = 123,
    OpBitcast = 124,
    OpSNegate = 126,
    OpFNegate = 127,
    OpIAdd = 128,
    OpFAdd = 129,
    OpISub = 130,
    OpFSub = 131,
    OpIMul = 132,
    OpFMul = 133,
    OpUDiv = 134,
    OpSDiv = 135,
    OpFDiv = 136,
    OpUMod = 137,
    OpSRem = 138,
    OpSMod = 139,
    OpFRem = 140,
    OpFMod = 141,
    OpVectorTimesScalar = 142,
    OpMatrixTimesScalar = 143,
    OpVectorTimesMatrix = 144,
    OpMatrixTimesVector = 145,
    OpMatrixTimesMatrix = 146,
    OpOuterProduct = 147,
    OpDot = 148,
    OpIAddCarry = 149,
    OpISubBorrow = 150,
    OpUMulExtended = 151,
    OpSMulExtended = 152,
    OpAny = 154,
    OpAll = 155,
    OpIsNan = 156,
    OpIsInf = 157,
    OpIsFinite = 158,
    OpIsNormal = 159,
    OpSignBitSet = 160,
    OpLessOrGreater = 161,
    OpOrdered = 162,
    OpUnordered = 163,
    OpLogicalEqual = 164,
    OpLogicalNotEqual = 165,
    OpLogicalOr = 166,
    OpLogicalAnd = 167,
    OpLogicalNot = 168,
    OpSelect = 169,
    OpIEqual = 170,
    OpINotEqual = 171,
    OpUGreaterThan = 172,
    OpSGreaterThan = 173,
    OpUGreaterThanEqual = 174,
    OpSGreaterThanEqual = 175,
    OpULessThan = 176,
    OpSLessThan = 177,
    OpULessThanEqual = 178,
    OpSLessThanEqual = 179,
    OpFOrdEqual = 180,
    OpFUnordEqual = 181,
    OpFOrdNotEqual = 182,
    OpFUnordNotEqual = 183,
    OpFOrdLessThan = 184,
    OpFUnordLessThan = 185,
    OpFOrdGreaterThan = 186,
    OpFUnordGreaterThan = 187,
    OpFOrdLessThanEqual = 188,
    OpFUnordLessThanEqual = 189,
    OpFOrdGreaterThanEqual = 190,
    OpFUnordGreaterThanEqual = 191,
    OpShiftRightLogical = 194,
    OpShiftRightArithmetic = 195,
    OpShiftLeftLogical = 196,
    OpBitwiseOr = 197,
    OpBitwiseXor = 198,
    OpBitwiseAnd = 199,
    OpNot = 200,
    OpBitFieldInsert = 201,
    OpBitFieldSExtract = 202,
    OpBitFieldUExtract = 203,
    OpBitReverse = 204,
    OpBitCount = 205,
    OpDPdx = 207,
    OpDPdy = 208,
    OpFwidth = 209,
    OpDPdxFine = 210,
    OpDPdyFine = 211,
    OpFwidthFine = 212,
    OpDPdxCoarse = 213,
    OpDPdyCoarse = 214,
    OpFwidthCoarse = 215,
    OpEmitVertex = 218,
    OpEndPrimitive = 219,
    OpEmitStreamVertex = 220,
    OpEndStreamPrimitive = 221,
    OpControlBarrier = 224,
    OpMemoryBarrier = 225,
    OpAtomicLoad = 227,
    OpAtomicStore = 228,
    OpAtomicExchange = 229,
    OpAtomicCompareExchange = 230,
    OpAtomicCompareExchangeWeak = 231,
    OpAtomicIIncrement = 232,
    OpAtomicIDecrement = 233,
    OpAtomicIAdd = 234,
    OpAtomicISub = 235,
    OpAtomicSMin = 236,
    OpAtomicUMin = 237,
    OpAtomicSMax = 238,
    OpAtomicUMax = 239,
    OpAtomicAnd = 240,
    OpAtomicOr = 241,
    OpAtomicXor = 242,
    OpPhi = 245,
    OpLoopMerge = 246,
    OpSelectionMerge = 247,
    OpLabel = 248,
    OpBranch = 249,
    OpBranchConditional = 250,
    OpSwitch = 251,
    OpKill = 252,
    OpReturn = 253,
    OpReturnValue = 254,
    OpUnreachable = 255,
    OpLifetimeStart = 256,
    OpLifetimeStop = 257,
    OpGroupAsyncCopy = 259,
    OpGroupWaitEvents = 260,
    OpGroupAll = 261,
    OpGroupAny = 262,
    OpGroupBroadcast = 263,
    OpGroupIAdd = 264,
    OpGroupFAdd = 265,
    OpGroupFMin = 266,
    OpGroupUMin = 267,
    OpGroupSMin = 268,
    OpGroupFMax = 269,
    OpGroupUMax = 270,
    OpGroupSMax = 271,
    OpReadPipe = 274,
    OpWritePipe = 275,
    OpReservedReadPipe = 276,
    OpReservedWritePipe = 277,
    OpReserveReadPipePackets = 278,
    OpReserveWritePipePackets = 279,
    OpCommitReadPipe = 280,
    OpCommitWritePipe = 281,
    OpIsValidReserveId = 282,
    OpGetNumPipePackets = 283,
    OpGetMaxPipePackets = 284,
    OpGroupReserveReadPipePackets = 285,
    OpGroupReserveWritePipePackets = 286,
    OpGroupCommitReadPipe = 287,
    OpGroupCommitWritePipe = 288,
    OpEnqueueMarker = 291,
    OpEnqueueKernel = 292,
    OpGetKernelNDrangeSubGroupCount = 293,
    OpGetKernelNDrangeMaxSubGroupSize = 294,
    OpGetKernelWorkGroupSize = 295,
    OpGetKernelPreferredWorkGroupSizeMultiple = 296,
    OpRetainEvent = 297,
    OpReleaseEvent = 298,
    OpCreateUserEvent = 299,
    OpIsValidEvent = 300,
    OpSetUserEventStatus = 301,
    OpCaptureEventProfilingInfo = 302,
    OpGetDefaultQueue = 303,
    OpBuildNDRange = 304,
    OpImageSparseSampleImplicitLod = 305,
    OpImageSparseSampleExplicitLod = 306,
    OpImageSparseSampleDrefImplicitLod = 307,
    OpImageSparseSampleDrefExplicitLod = 308,
    OpImageSparseSampleProjImplicitLod = 309,
    OpImageSparseSampleProjExplicitLod = 310,
    OpImageSparseSampleProjDrefImplicitLod = 311,
    OpImageSparseSampleProjDrefExplicitLod = 312,
    OpImageSparseFetch = 313,
    OpImageSparseGather = 314,
    OpImageSparseDrefGather = 315,
    OpImageSparseTexelsResident = 316,
    OpNoLine = 317,
    OpAtomicFlagTestAndSet = 318,
    OpAtomicFlagClear = 319,
    OpImageSparseRead = 320,
    OpSizeOf = 321,
    OpTypePipeStorage = 322,
    OpConstantPipeStorage = 323,
    OpCreatePipeFromPipeStorage = 324,
    OpGetKernelLocalSizeForSubgroupCount = 325,
    OpGetKernelMaxNumSubgroups = 326,
    OpTypeNamedBarrier = 327,
    OpNamedBarrierInitialize = 328,
    OpMemoryNamedBarrier = 329,
    OpModuleProcessed = 330,
    OpExecutionModeId = 331,
    OpDecorateId = 332,
    OpGroupNonUniformElect = 333,
    OpGroupNonUniformAll = 334,
    OpGroupNonUniformAny = 335,
    OpGroupNonUniformAllEqual = 336,
    OpGroupNonUniformBroadcast = 337,
    OpGroupNonUniformBroadcastFirst = 338,
    OpGroupNonUniformBallot = 339,
    OpGroupNonUniformInverseBallot = 340,
    OpGroupNonUniformBallotBitExtract = 341,
    OpGroupNonUniformBallotBitCount = 342,
    OpGroupNonUniformBallotFindLSB = 343,
    OpGroupNonUniformBallotFindMSB = 344,
    OpGroupNonUniformShuffle = 345,
    OpGroupNonUniformShuffleXor = 346,
    OpGroupNonUniformShuffleUp = 347,
    OpGroupNonUniformShuffleDown = 348,
    OpGroupNonUniformIAdd = 349,
    OpGroupNonUniformFAdd = 350,
    OpGroupNonUniformIMul = 351,
    OpGroupNonUniformFMul = 352,
    OpGroupNonUniformSMin = 353,
    OpGroupNonUniformUMin = 354,
    OpGroupNonUniformFMin = 355,
    OpGroupNonUniformSMax = 356,
    OpGroupNonUniformUMax = 357,
    OpGroupNonUniformFMax = 358,
    OpGroupNonUniformBitwiseAnd = 359,
    OpGroupNonUniformBitwiseOr = 360,
    OpGroupNonUniformBitwiseXor = 361,
    OpGroupNonUniformLogicalAnd = 362,
    OpGroupNonUniformLogicalOr = 363,
    OpGroupNonUniformLogicalXor = 364,
    OpGroupNonUniformQuadBroadcast = 365,
    OpGroupNonUniformQuadSwap = 366,
    OpCopyLogical = 400,
    OpPtrEqual = 401,
    OpPtrNotEqual = 402,
    OpPtrDiff = 403,
    OpColorAttachmentReadEXT = 4160,
    OpDepthAttachmentReadEXT = 4161,
    OpStencilAttachmentReadEXT = 4162,
    OpTerminateInvocation = 4416,
    OpSubgroupBallotKHR = 4421,
    OpSubgroupFirstInvocationKHR = 4422,
    OpSubgroupAllKHR = 4428,
    OpSubgroupAnyKHR = 4429,
    OpSubgroupAllEqualKHR = 4430,
    OpGroupNonUniformRotateKHR = 4431,
    OpSubgroupReadInvocationKHR = 4432,
    OpTraceRayKHR = 4445,
    OpExecuteCallableKHR = 4446,
    OpConvertUToAccelerationStructureKHR = 4447,
    OpIgnoreIntersectionKHR = 4448,
    OpTerminateRayKHR = 4449,
    OpSDot = 4450,
    OpUDot = 4451,
    OpSUDot = 4452,
    OpSDotAccSat = 4453,
    OpUDotAccSat = 4454,
    OpSUDotAccSat = 4455,
    OpTypeCooperativeMatrixKHR = 4456,
    OpCooperativeMatrixLoadKHR = 4457,
    OpCooperativeMatrixStoreKHR = 4458,
    OpCooperativeMatrixMulAddKHR = 4459,
    OpCooperativeMatrixLengthKHR = 4460,
    OpTypeRayQueryKHR = 4472,
    OpRayQueryInitializeKHR = 4473,
    OpRayQueryTerminateKHR = 4474,
    OpRayQueryGenerateIntersectionKHR = 4475,
    OpRayQueryConfirmIntersectionKHR = 4476,
    OpRayQueryProceedKHR = 4477,
    OpRayQueryGetIntersectionTypeKHR = 4479,
    OpImageSampleWeightedQCOM = 4480,
    OpImageBoxFilterQCOM = 4481,
    OpImageBlockMatchSSDQCOM = 4482,
    OpImageBlockMatchSADQCOM = 4483,
    OpImageBlockMatchWindowSSDQCOM = 4500,
    OpImageBlockMatchWindowSADQCOM = 4501,
    OpImageBlockMatchGatherSSDQCOM = 4502,
    OpImageBlockMatchGatherSADQCOM = 4503,
    OpGroupIAddNonUniformAMD = 5000,
    OpGroupFAddNonUniformAMD = 5001,
    OpGroupFMinNonUniformAMD = 5002,
    OpGroupUMinNonUniformAMD = 5003,
    OpGroupSMinNonUniformAMD = 5004,
    OpGroupFMaxNonUniformAMD = 5005,
    OpGroupUMaxNonUniformAMD = 5006,
    OpGroupSMaxNonUniformAMD = 5007,
    OpFragmentMaskFetchAMD = 5011,
    OpFragmentFetchAMD = 5012,
    OpReadClockKHR = 5056,
    OpFinalizeNodePayloadsAMDX = 5075,
    OpFinishWritingNodePayloadAMDX = 5078,
    OpInitializeNodePayloadsAMDX = 5090,
    OpGroupNonUniformQuadAllKHR = 5110,
    OpGroupNonUniformQuadAnyKHR = 5111,
    OpHitObjectRecordHitMotionNV = 5249,
    OpHitObjectRecordHitWithIndexMotionNV = 5250,
    OpHitObjectRecordMissMotionNV = 5251,
    OpHitObjectGetWorldToObjectNV = 5252,
    OpHitObjectGetObjectToWorldNV = 5253,
    OpHitObjectGetObjectRayDirectionNV = 5254,
    OpHitObjectGetObjectRayOriginNV = 5255,
    OpHitObjectTraceRayMotionNV = 5256,
    OpHitObjectGetShaderRecordBufferHandleNV = 5257,
    OpHitObjectGetShaderBindingTableRecordIndexNV = 5258,
    OpHitObjectRecordEmptyNV = 5259,
    OpHitObjectTraceRayNV = 5260,
    OpHitObjectRecordHitNV = 5261,
    OpHitObjectRecordHitWithIndexNV = 5262,
    OpHitObjectRecordMissNV = 5263,
    OpHitObjectExecuteShaderNV = 5264,
    OpHitObjectGetCurrentTimeNV = 5265,
    OpHitObjectGetAttributesNV = 5266,
    OpHitObjectGetHitKindNV = 5267,
    OpHitObjectGetPrimitiveIndexNV = 5268,
    OpHitObjectGetGeometryIndexNV = 5269,
    OpHitObjectGetInstanceIdNV = 5270,
    OpHitObjectGetInstanceCustomIndexNV = 5271,
    OpHitObjectGetWorldRayDirectionNV = 5272,
    OpHitObjectGetWorldRayOriginNV = 5273,
    OpHitObjectGetRayTMaxNV = 5274,
    OpHitObjectGetRayTMinNV = 5275,
    OpHitObjectIsEmptyNV = 5276,
    OpHitObjectIsHitNV = 5277,
    OpHitObjectIsMissNV = 5278,
    OpReorderThreadWithHitObjectNV = 5279,
    OpReorderThreadWithHintNV = 5280,
    OpTypeHitObjectNV = 5281,
    OpImageSampleFootprintNV = 5283,
    OpEmitMeshTasksEXT = 5294,
    OpSetMeshOutputsEXT = 5295,
    OpGroupNonUniformPartitionNV = 5296,
    OpWritePackedPrimitiveIndices4x8NV = 5299,
    OpFetchMicroTriangleVertexPositionNV = 5300,
    OpFetchMicroTriangleVertexBarycentricNV = 5301,
    OpReportIntersectionKHR = 5334,
    OpIgnoreIntersectionNV = 5335,
    OpTerminateRayNV = 5336,
    OpTraceNV = 5337,
    OpTraceMotionNV = 5338,
    OpTraceRayMotionNV = 5339,
    OpRayQueryGetIntersectionTriangleVertexPositionsKHR = 5340,
    OpTypeAccelerationStructureKHR = 5341,
    OpExecuteCallableNV = 5344,
    OpTypeCooperativeMatrixNV = 5358,
    OpCooperativeMatrixLoadNV = 5359,
    OpCooperativeMatrixStoreNV = 5360,
    OpCooperativeMatrixMulAddNV = 5361,
    OpCooperativeMatrixLengthNV = 5362,
    OpBeginInvocationInterlockEXT = 5364,
    OpEndInvocationInterlockEXT = 5365,
    OpDemoteToHelperInvocation = 5380,
    OpIsHelperInvocationEXT = 5381,
    OpConvertUToImageNV = 5391,
    OpConvertUToSamplerNV = 5392,
    OpConvertImageToUNV = 5393,
    OpConvertSamplerToUNV = 5394,
    OpConvertUToSampledImageNV = 5395,
    OpConvertSampledImageToUNV = 5396,
    OpSamplerImageAddressingModeNV = 5397,
    OpRawAccessChainNV = 5398,
    OpSubgroupShuffleINTEL = 5571,
    OpSubgroupShuffleDownINTEL = 5572,
    OpSubgroupShuffleUpINTEL = 5573,
    OpSubgroupShuffleXorINTEL = 5574,
    OpSubgroupBlockReadINTEL = 5575,
    OpSubgroupBlockWriteINTEL = 5576,
    OpSubgroupImageBlockReadINTEL = 5577,
    OpSubgroupImageBlockWriteINTEL = 5578,
    OpSubgroupImageMediaBlockReadINTEL = 5580,
    OpSubgroupImageMediaBlockWriteINTEL = 5581,
    OpUCountLeadingZerosINTEL = 5585,
    OpUCountTrailingZerosINTEL = 5586,
    OpAbsISubINTEL = 5587,
    OpAbsUSubINTEL = 5588,
    OpIAddSatINTEL = 5589,
    OpUAddSatINTEL = 5590,
    OpIAverageINTEL = 5591,
    OpUAverageINTEL = 5592,
    OpIAverageRoundedINTEL = 5593,
    OpUAverageRoundedINTEL = 5594,
    OpISubSatINTEL = 5595,
    OpUSubSatINTEL = 5596,
    OpIMul32x16INTEL = 5597,
    OpUMul32x16INTEL = 5598,
    OpAtomicFMinEXT = 5614,
    OpAtomicFMaxEXT = 5615,
    OpAssumeTrueKHR = 5630,
    OpExpectKHR = 5631,
    OpDecorateString = 5632,
    OpMemberDecorateString = 5633,
    OpLoopControlINTEL = 5887,
    OpReadPipeBlockingINTEL = 5946,
    OpWritePipeBlockingINTEL = 5947,
    OpFPGARegINTEL = 5949,
    OpRayQueryGetRayTMinKHR = 6016,
    OpRayQueryGetRayFlagsKHR = 6017,
    OpRayQueryGetIntersectionTKHR = 6018,
    OpRayQueryGetIntersectionInstanceCustomIndexKHR = 6019,
    OpRayQueryGetIntersectionInstanceIdKHR = 6020,
    OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR = 6021,
    OpRayQueryGetIntersectionGeometryIndexKHR = 6022,
    OpRayQueryGetIntersectionPrimitiveIndexKHR = 6023,
    OpRayQueryGetIntersectionBarycentricsKHR = 6024,
    OpRayQueryGetIntersectionFrontFaceKHR = 6025,
    OpRayQueryGetIntersectionCandidateAABBOpaqueKHR = 6026,
    OpRayQueryGetIntersectionObjectRayDirectionKHR = 6027,
    OpRayQueryGetIntersectionObjectRayOriginKHR = 6028,
    OpRayQueryGetWorldRayDirectionKHR = 6029,
    OpRayQueryGetWorldRayOriginKHR = 6030,
    OpRayQueryGetIntersectionObjectToWorldKHR = 6031,
    OpRayQueryGetIntersectionWorldToObjectKHR = 6032,
    OpAtomicFAddEXT = 6035,
    OpTypeBufferSurfaceINTEL = 6086,
    OpTypeStructContinuedINTEL = 6090,
    OpConstantCompositeContinuedINTEL = 6091,
    OpSpecConstantCompositeContinuedINTEL = 6092,
    OpCompositeConstructContinuedINTEL = 6096,
    OpConvertFToBF16INTEL = 6116,
    OpConvertBF16ToFINTEL = 6117,
    OpControlBarrierArriveINTEL = 6142,
    OpControlBarrierWaitINTEL = 6143,
    OpGroupIMulKHR = 6401,
    OpGroupFMulKHR = 6402,
    OpGroupBitwiseAndKHR = 6403,
    OpGroupBitwiseOrKHR = 6404,
    OpGroupBitwiseXorKHR = 6405,
    OpGroupLogicalAndKHR = 6406,
    OpGroupLogicalOrKHR = 6407,
    OpGroupLogicalXorKHR = 6408,
    OpMaskedGatherINTEL = 6428,
    OpMaskedScatterINTEL = 6429,
    pub const OpSDotKHR = Opcode.OpSDot;
    pub const OpUDotKHR = Opcode.OpUDot;
    pub const OpSUDotKHR = Opcode.OpSUDot;
    pub const OpSDotAccSatKHR = Opcode.OpSDotAccSat;
    pub const OpUDotAccSatKHR = Opcode.OpUDotAccSat;
    pub const OpSUDotAccSatKHR = Opcode.OpSUDotAccSat;
    pub const OpReportIntersectionNV = Opcode.OpReportIntersectionKHR;
    pub const OpTypeAccelerationStructureNV = Opcode.OpTypeAccelerationStructureKHR;
    pub const OpDemoteToHelperInvocationEXT = Opcode.OpDemoteToHelperInvocation;
    pub const OpDecorateStringGOOGLE = Opcode.OpDecorateString;
    pub const OpMemberDecorateStringGOOGLE = Opcode.OpMemberDecorateString;

    pub fn Operands(comptime self: Opcode) type {
        return switch (self) {
            .OpNop => void,
            .OpUndef => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpSourceContinued => struct { continued_source: LiteralString },
            .OpSource => struct { source_language: SourceLanguage, version: LiteralInteger, file: ?IdRef = null, source: ?LiteralString = null },
            .OpSourceExtension => struct { extension: LiteralString },
            .OpName => struct { target: IdRef, name: LiteralString },
            .OpMemberName => struct { type: IdRef, member: LiteralInteger, name: LiteralString },
            .OpString => struct { id_result: IdResult, string: LiteralString },
            .OpLine => struct { file: IdRef, line: LiteralInteger, column: LiteralInteger },
            .OpExtension => struct { name: LiteralString },
            .OpExtInstImport => struct { id_result: IdResult, name: LiteralString },
            .OpExtInst => struct { id_result_type: IdResultType, id_result: IdResult, set: IdRef, instruction: LiteralExtInstInteger, id_ref_4: []const IdRef = &.{} },
            .OpMemoryModel => struct { addressing_model: AddressingModel, memory_model: MemoryModel },
            .OpEntryPoint => struct { execution_model: ExecutionModel, entry_point: IdRef, name: LiteralString, interface: []const IdRef = &.{} },
            .OpExecutionMode => struct { entry_point: IdRef, mode: ExecutionMode.Extended },
            .OpCapability => struct { capability: Capability },
            .OpTypeVoid => struct { id_result: IdResult },
            .OpTypeBool => struct { id_result: IdResult },
            .OpTypeInt => struct { id_result: IdResult, width: LiteralInteger, signedness: LiteralInteger },
            .OpTypeFloat => struct { id_result: IdResult, width: LiteralInteger },
            .OpTypeVector => struct { id_result: IdResult, component_type: IdRef, component_count: LiteralInteger },
            .OpTypeMatrix => struct { id_result: IdResult, column_type: IdRef, column_count: LiteralInteger },
            .OpTypeImage => struct { id_result: IdResult, sampled_type: IdRef, dim: Dim, depth: LiteralInteger, arrayed: LiteralInteger, ms: LiteralInteger, sampled: LiteralInteger, image_format: ImageFormat, access_qualifier: ?AccessQualifier = null },
            .OpTypeSampler => struct { id_result: IdResult },
            .OpTypeSampledImage => struct { id_result: IdResult, image_type: IdRef },
            .OpTypeArray => struct { id_result: IdResult, element_type: IdRef, length: IdRef },
            .OpTypeRuntimeArray => struct { id_result: IdResult, element_type: IdRef },
            .OpTypeStruct => struct { id_result: IdResult, id_ref: []const IdRef = &.{} },
            .OpTypeOpaque => struct { id_result: IdResult, literal_string: LiteralString },
            .OpTypePointer => struct { id_result: IdResult, storage_class: StorageClass, type: IdRef },
            .OpTypeFunction => struct { id_result: IdResult, return_type: IdRef, id_ref_2: []const IdRef = &.{} },
            .OpTypeEvent => struct { id_result: IdResult },
            .OpTypeDeviceEvent => struct { id_result: IdResult },
            .OpTypeReserveId => struct { id_result: IdResult },
            .OpTypeQueue => struct { id_result: IdResult },
            .OpTypePipe => struct { id_result: IdResult, qualifier: AccessQualifier },
            .OpTypeForwardPointer => struct { pointer_type: IdRef, storage_class: StorageClass },
            .OpConstantTrue => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpConstantFalse => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpConstant => struct { id_result_type: IdResultType, id_result: IdResult, value: LiteralContextDependentNumber },
            .OpConstantComposite => struct { id_result_type: IdResultType, id_result: IdResult, constituents: []const IdRef = &.{} },
            .OpConstantSampler => struct { id_result_type: IdResultType, id_result: IdResult, sampler_addressing_mode: SamplerAddressingMode, param: LiteralInteger, sampler_filter_mode: SamplerFilterMode },
            .OpConstantNull => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpSpecConstantTrue => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpSpecConstantFalse => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpSpecConstant => struct { id_result_type: IdResultType, id_result: IdResult, value: LiteralContextDependentNumber },
            .OpSpecConstantComposite => struct { id_result_type: IdResultType, id_result: IdResult, constituents: []const IdRef = &.{} },
            .OpSpecConstantOp => struct { id_result_type: IdResultType, id_result: IdResult, opcode: LiteralSpecConstantOpInteger },
            .OpFunction => struct { id_result_type: IdResultType, id_result: IdResult, function_control: FunctionControl, function_type: IdRef },
            .OpFunctionParameter => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpFunctionEnd => void,
            .OpFunctionCall => struct { id_result_type: IdResultType, id_result: IdResult, function: IdRef, id_ref_3: []const IdRef = &.{} },
            .OpVariable => struct { id_result_type: IdResultType, id_result: IdResult, storage_class: StorageClass, initializer: ?IdRef = null },
            .OpImageTexelPointer => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, sample: IdRef },
            .OpLoad => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory_access: ?MemoryAccess.Extended = null },
            .OpStore => struct { pointer: IdRef, object: IdRef, memory_access: ?MemoryAccess.Extended = null },
            .OpCopyMemory => struct { target: IdRef, source: IdRef, memory_access_2: ?MemoryAccess.Extended = null, memory_access_3: ?MemoryAccess.Extended = null },
            .OpCopyMemorySized => struct { target: IdRef, source: IdRef, size: IdRef, memory_access_3: ?MemoryAccess.Extended = null, memory_access_4: ?MemoryAccess.Extended = null },
            .OpAccessChain => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, indexes: []const IdRef = &.{} },
            .OpInBoundsAccessChain => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, indexes: []const IdRef = &.{} },
            .OpPtrAccessChain => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, element: IdRef, indexes: []const IdRef = &.{} },
            .OpArrayLength => struct { id_result_type: IdResultType, id_result: IdResult, structure: IdRef, array_member: LiteralInteger },
            .OpGenericPtrMemSemantics => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef },
            .OpInBoundsPtrAccessChain => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, element: IdRef, indexes: []const IdRef = &.{} },
            .OpDecorate => struct { target: IdRef, decoration: Decoration.Extended },
            .OpMemberDecorate => struct { structure_type: IdRef, member: LiteralInteger, decoration: Decoration.Extended },
            .OpDecorationGroup => struct { id_result: IdResult },
            .OpGroupDecorate => struct { decoration_group: IdRef, targets: []const IdRef = &.{} },
            .OpGroupMemberDecorate => struct { decoration_group: IdRef, targets: []const PairIdRefLiteralInteger = &.{} },
            .OpVectorExtractDynamic => struct { id_result_type: IdResultType, id_result: IdResult, vector: IdRef, index: IdRef },
            .OpVectorInsertDynamic => struct { id_result_type: IdResultType, id_result: IdResult, vector: IdRef, component: IdRef, index: IdRef },
            .OpVectorShuffle => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, components: []const LiteralInteger = &.{} },
            .OpCompositeConstruct => struct { id_result_type: IdResultType, id_result: IdResult, constituents: []const IdRef = &.{} },
            .OpCompositeExtract => struct { id_result_type: IdResultType, id_result: IdResult, composite: IdRef, indexes: []const LiteralInteger = &.{} },
            .OpCompositeInsert => struct { id_result_type: IdResultType, id_result: IdResult, object: IdRef, composite: IdRef, indexes: []const LiteralInteger = &.{} },
            .OpCopyObject => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpTranspose => struct { id_result_type: IdResultType, id_result: IdResult, matrix: IdRef },
            .OpSampledImage => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, sampler: IdRef },
            .OpImageSampleImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSampleExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSampleDrefImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSampleDrefExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSampleProjImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSampleProjExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSampleProjDrefImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSampleProjDrefExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ImageOperands.Extended },
            .OpImageFetch => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageGather => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, component: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageDrefGather => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageRead => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageWrite => struct { image: IdRef, coordinate: IdRef, texel: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImage => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef },
            .OpImageQueryFormat => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef },
            .OpImageQueryOrder => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef },
            .OpImageQuerySizeLod => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, level_of_detail: IdRef },
            .OpImageQuerySize => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef },
            .OpImageQueryLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef },
            .OpImageQueryLevels => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef },
            .OpImageQuerySamples => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef },
            .OpConvertFToU => struct { id_result_type: IdResultType, id_result: IdResult, float_value: IdRef },
            .OpConvertFToS => struct { id_result_type: IdResultType, id_result: IdResult, float_value: IdRef },
            .OpConvertSToF => struct { id_result_type: IdResultType, id_result: IdResult, signed_value: IdRef },
            .OpConvertUToF => struct { id_result_type: IdResultType, id_result: IdResult, unsigned_value: IdRef },
            .OpUConvert => struct { id_result_type: IdResultType, id_result: IdResult, unsigned_value: IdRef },
            .OpSConvert => struct { id_result_type: IdResultType, id_result: IdResult, signed_value: IdRef },
            .OpFConvert => struct { id_result_type: IdResultType, id_result: IdResult, float_value: IdRef },
            .OpQuantizeToF16 => struct { id_result_type: IdResultType, id_result: IdResult, value: IdRef },
            .OpConvertPtrToU => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef },
            .OpSatConvertSToU => struct { id_result_type: IdResultType, id_result: IdResult, signed_value: IdRef },
            .OpSatConvertUToS => struct { id_result_type: IdResultType, id_result: IdResult, unsigned_value: IdRef },
            .OpConvertUToPtr => struct { id_result_type: IdResultType, id_result: IdResult, integer_value: IdRef },
            .OpPtrCastToGeneric => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef },
            .OpGenericCastToPtr => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef },
            .OpGenericCastToPtrExplicit => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, storage: StorageClass },
            .OpBitcast => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpSNegate => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpFNegate => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpIAdd => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFAdd => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpISub => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFSub => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpIMul => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFMul => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUDiv => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSDiv => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFDiv => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUMod => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSRem => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSMod => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFRem => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFMod => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpVectorTimesScalar => struct { id_result_type: IdResultType, id_result: IdResult, vector: IdRef, scalar: IdRef },
            .OpMatrixTimesScalar => struct { id_result_type: IdResultType, id_result: IdResult, matrix: IdRef, scalar: IdRef },
            .OpVectorTimesMatrix => struct { id_result_type: IdResultType, id_result: IdResult, vector: IdRef, matrix: IdRef },
            .OpMatrixTimesVector => struct { id_result_type: IdResultType, id_result: IdResult, matrix: IdRef, vector: IdRef },
            .OpMatrixTimesMatrix => struct { id_result_type: IdResultType, id_result: IdResult, leftmatrix: IdRef, rightmatrix: IdRef },
            .OpOuterProduct => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef },
            .OpDot => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef },
            .OpIAddCarry => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpISubBorrow => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUMulExtended => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSMulExtended => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpAny => struct { id_result_type: IdResultType, id_result: IdResult, vector: IdRef },
            .OpAll => struct { id_result_type: IdResultType, id_result: IdResult, vector: IdRef },
            .OpIsNan => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef },
            .OpIsInf => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef },
            .OpIsFinite => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef },
            .OpIsNormal => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef },
            .OpSignBitSet => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef },
            .OpLessOrGreater => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef, y: IdRef },
            .OpOrdered => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef, y: IdRef },
            .OpUnordered => struct { id_result_type: IdResultType, id_result: IdResult, x: IdRef, y: IdRef },
            .OpLogicalEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpLogicalNotEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpLogicalOr => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpLogicalAnd => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpLogicalNot => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpSelect => struct { id_result_type: IdResultType, id_result: IdResult, condition: IdRef, object_1: IdRef, object_2: IdRef },
            .OpIEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpINotEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUGreaterThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSGreaterThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUGreaterThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSGreaterThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpULessThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSLessThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpULessThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpSLessThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFOrdEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFUnordEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFOrdNotEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFUnordNotEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFOrdLessThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFUnordLessThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFOrdGreaterThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFUnordGreaterThan => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFOrdLessThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFUnordLessThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFOrdGreaterThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpFUnordGreaterThanEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpShiftRightLogical => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, shift: IdRef },
            .OpShiftRightArithmetic => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, shift: IdRef },
            .OpShiftLeftLogical => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, shift: IdRef },
            .OpBitwiseOr => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpBitwiseXor => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpBitwiseAnd => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpNot => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpBitFieldInsert => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, insert: IdRef, offset: IdRef, count: IdRef },
            .OpBitFieldSExtract => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, offset: IdRef, count: IdRef },
            .OpBitFieldUExtract => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, offset: IdRef, count: IdRef },
            .OpBitReverse => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef },
            .OpBitCount => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef },
            .OpDPdx => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpDPdy => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpFwidth => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpDPdxFine => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpDPdyFine => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpFwidthFine => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpDPdxCoarse => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpDPdyCoarse => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpFwidthCoarse => struct { id_result_type: IdResultType, id_result: IdResult, p: IdRef },
            .OpEmitVertex => void,
            .OpEndPrimitive => void,
            .OpEmitStreamVertex => struct { stream: IdRef },
            .OpEndStreamPrimitive => struct { stream: IdRef },
            .OpControlBarrier => struct { execution: IdScope, memory: IdScope, semantics: IdMemorySemantics },
            .OpMemoryBarrier => struct { memory: IdScope, semantics: IdMemorySemantics },
            .OpAtomicLoad => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics },
            .OpAtomicStore => struct { pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicExchange => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicCompareExchange => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, equal: IdMemorySemantics, unequal: IdMemorySemantics, value: IdRef, comparator: IdRef },
            .OpAtomicCompareExchangeWeak => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, equal: IdMemorySemantics, unequal: IdMemorySemantics, value: IdRef, comparator: IdRef },
            .OpAtomicIIncrement => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics },
            .OpAtomicIDecrement => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics },
            .OpAtomicIAdd => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicISub => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicSMin => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicUMin => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicSMax => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicUMax => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicAnd => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicOr => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicXor => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpPhi => struct { id_result_type: IdResultType, id_result: IdResult, pair_id_ref_id_ref: []const PairIdRefIdRef = &.{} },
            .OpLoopMerge => struct { merge_block: IdRef, continue_target: IdRef, loop_control: LoopControl.Extended },
            .OpSelectionMerge => struct { merge_block: IdRef, selection_control: SelectionControl },
            .OpLabel => struct { id_result: IdResult },
            .OpBranch => struct { target_label: IdRef },
            .OpBranchConditional => struct { condition: IdRef, true_label: IdRef, false_label: IdRef, branch_weights: []const LiteralInteger = &.{} },
            .OpSwitch => struct { selector: IdRef, default: IdRef, target: []const PairLiteralIntegerIdRef = &.{} },
            .OpKill => void,
            .OpReturn => void,
            .OpReturnValue => struct { value: IdRef },
            .OpUnreachable => void,
            .OpLifetimeStart => struct { pointer: IdRef, size: LiteralInteger },
            .OpLifetimeStop => struct { pointer: IdRef, size: LiteralInteger },
            .OpGroupAsyncCopy => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, destination: IdRef, source: IdRef, num_elements: IdRef, stride: IdRef, event: IdRef },
            .OpGroupWaitEvents => struct { execution: IdScope, num_events: IdRef, events_list: IdRef },
            .OpGroupAll => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, predicate: IdRef },
            .OpGroupAny => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, predicate: IdRef },
            .OpGroupBroadcast => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, localid: IdRef },
            .OpGroupIAdd => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFAdd => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFMin => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupUMin => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupSMin => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFMax => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupUMax => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupSMax => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpReadPipe => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, pointer: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpWritePipe => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, pointer: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpReservedReadPipe => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, reserve_id: IdRef, index: IdRef, pointer: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpReservedWritePipe => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, reserve_id: IdRef, index: IdRef, pointer: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpReserveReadPipePackets => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, num_packets: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpReserveWritePipePackets => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, num_packets: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpCommitReadPipe => struct { pipe: IdRef, reserve_id: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpCommitWritePipe => struct { pipe: IdRef, reserve_id: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpIsValidReserveId => struct { id_result_type: IdResultType, id_result: IdResult, reserve_id: IdRef },
            .OpGetNumPipePackets => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpGetMaxPipePackets => struct { id_result_type: IdResultType, id_result: IdResult, pipe: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpGroupReserveReadPipePackets => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, pipe: IdRef, num_packets: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpGroupReserveWritePipePackets => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, pipe: IdRef, num_packets: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpGroupCommitReadPipe => struct { execution: IdScope, pipe: IdRef, reserve_id: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpGroupCommitWritePipe => struct { execution: IdScope, pipe: IdRef, reserve_id: IdRef, packet_size: IdRef, packet_alignment: IdRef },
            .OpEnqueueMarker => struct { id_result_type: IdResultType, id_result: IdResult, queue: IdRef, num_events: IdRef, wait_events: IdRef, ret_event: IdRef },
            .OpEnqueueKernel => struct { id_result_type: IdResultType, id_result: IdResult, queue: IdRef, flags: IdRef, nd_range: IdRef, num_events: IdRef, wait_events: IdRef, ret_event: IdRef, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef, local_size: []const IdRef = &.{} },
            .OpGetKernelNDrangeSubGroupCount => struct { id_result_type: IdResultType, id_result: IdResult, nd_range: IdRef, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef },
            .OpGetKernelNDrangeMaxSubGroupSize => struct { id_result_type: IdResultType, id_result: IdResult, nd_range: IdRef, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef },
            .OpGetKernelWorkGroupSize => struct { id_result_type: IdResultType, id_result: IdResult, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef },
            .OpGetKernelPreferredWorkGroupSizeMultiple => struct { id_result_type: IdResultType, id_result: IdResult, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef },
            .OpRetainEvent => struct { event: IdRef },
            .OpReleaseEvent => struct { event: IdRef },
            .OpCreateUserEvent => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpIsValidEvent => struct { id_result_type: IdResultType, id_result: IdResult, event: IdRef },
            .OpSetUserEventStatus => struct { event: IdRef, status: IdRef },
            .OpCaptureEventProfilingInfo => struct { event: IdRef, profiling_info: IdRef, value: IdRef },
            .OpGetDefaultQueue => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpBuildNDRange => struct { id_result_type: IdResultType, id_result: IdResult, globalworksize: IdRef, localworksize: IdRef, globalworkoffset: IdRef },
            .OpImageSparseSampleImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseSampleExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSparseSampleDrefImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseSampleDrefExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSparseSampleProjImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseSampleProjExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSparseSampleProjDrefImplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseSampleProjDrefExplicitLod => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ImageOperands.Extended },
            .OpImageSparseFetch => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseGather => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, component: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseDrefGather => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, d_ref: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpImageSparseTexelsResident => struct { id_result_type: IdResultType, id_result: IdResult, resident_code: IdRef },
            .OpNoLine => void,
            .OpAtomicFlagTestAndSet => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics },
            .OpAtomicFlagClear => struct { pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics },
            .OpImageSparseRead => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpSizeOf => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef },
            .OpTypePipeStorage => struct { id_result: IdResult },
            .OpConstantPipeStorage => struct { id_result_type: IdResultType, id_result: IdResult, packet_size: LiteralInteger, packet_alignment: LiteralInteger, capacity: LiteralInteger },
            .OpCreatePipeFromPipeStorage => struct { id_result_type: IdResultType, id_result: IdResult, pipe_storage: IdRef },
            .OpGetKernelLocalSizeForSubgroupCount => struct { id_result_type: IdResultType, id_result: IdResult, subgroup_count: IdRef, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef },
            .OpGetKernelMaxNumSubgroups => struct { id_result_type: IdResultType, id_result: IdResult, invoke: IdRef, param: IdRef, param_size: IdRef, param_align: IdRef },
            .OpTypeNamedBarrier => struct { id_result: IdResult },
            .OpNamedBarrierInitialize => struct { id_result_type: IdResultType, id_result: IdResult, subgroup_count: IdRef },
            .OpMemoryNamedBarrier => struct { named_barrier: IdRef, memory: IdScope, semantics: IdMemorySemantics },
            .OpModuleProcessed => struct { process: LiteralString },
            .OpExecutionModeId => struct { entry_point: IdRef, mode: ExecutionMode.Extended },
            .OpDecorateId => struct { target: IdRef, decoration: Decoration.Extended },
            .OpGroupNonUniformElect => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope },
            .OpGroupNonUniformAll => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, predicate: IdRef },
            .OpGroupNonUniformAny => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, predicate: IdRef },
            .OpGroupNonUniformAllEqual => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef },
            .OpGroupNonUniformBroadcast => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, id: IdRef },
            .OpGroupNonUniformBroadcastFirst => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef },
            .OpGroupNonUniformBallot => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, predicate: IdRef },
            .OpGroupNonUniformInverseBallot => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef },
            .OpGroupNonUniformBallotBitExtract => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, index: IdRef },
            .OpGroupNonUniformBallotBitCount => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef },
            .OpGroupNonUniformBallotFindLSB => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef },
            .OpGroupNonUniformBallotFindMSB => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef },
            .OpGroupNonUniformShuffle => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, id: IdRef },
            .OpGroupNonUniformShuffleXor => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, mask: IdRef },
            .OpGroupNonUniformShuffleUp => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, delta: IdRef },
            .OpGroupNonUniformShuffleDown => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, delta: IdRef },
            .OpGroupNonUniformIAdd => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformFAdd => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformIMul => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformFMul => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformSMin => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformUMin => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformFMin => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformSMax => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformUMax => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformFMax => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformBitwiseAnd => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformBitwiseOr => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformBitwiseXor => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformLogicalAnd => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformLogicalOr => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformLogicalXor => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, value: IdRef, clustersize: ?IdRef = null },
            .OpGroupNonUniformQuadBroadcast => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, index: IdRef },
            .OpGroupNonUniformQuadSwap => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, direction: IdRef },
            .OpCopyLogical => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpPtrEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpPtrNotEqual => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpPtrDiff => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpColorAttachmentReadEXT => struct { id_result_type: IdResultType, id_result: IdResult, attachment: IdRef, sample: ?IdRef = null },
            .OpDepthAttachmentReadEXT => struct { id_result_type: IdResultType, id_result: IdResult, sample: ?IdRef = null },
            .OpStencilAttachmentReadEXT => struct { id_result_type: IdResultType, id_result: IdResult, sample: ?IdRef = null },
            .OpTerminateInvocation => void,
            .OpSubgroupBallotKHR => struct { id_result_type: IdResultType, id_result: IdResult, predicate: IdRef },
            .OpSubgroupFirstInvocationKHR => struct { id_result_type: IdResultType, id_result: IdResult, value: IdRef },
            .OpSubgroupAllKHR => struct { id_result_type: IdResultType, id_result: IdResult, predicate: IdRef },
            .OpSubgroupAnyKHR => struct { id_result_type: IdResultType, id_result: IdResult, predicate: IdRef },
            .OpSubgroupAllEqualKHR => struct { id_result_type: IdResultType, id_result: IdResult, predicate: IdRef },
            .OpGroupNonUniformRotateKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, value: IdRef, delta: IdRef, clustersize: ?IdRef = null },
            .OpSubgroupReadInvocationKHR => struct { id_result_type: IdResultType, id_result: IdResult, value: IdRef, index: IdRef },
            .OpTraceRayKHR => struct { accel: IdRef, ray_flags: IdRef, cull_mask: IdRef, sbt_offset: IdRef, sbt_stride: IdRef, miss_index: IdRef, ray_origin: IdRef, ray_tmin: IdRef, ray_direction: IdRef, ray_tmax: IdRef, payload: IdRef },
            .OpExecuteCallableKHR => struct { sbt_index: IdRef, callable_data: IdRef },
            .OpConvertUToAccelerationStructureKHR => struct { id_result_type: IdResultType, id_result: IdResult, accel: IdRef },
            .OpIgnoreIntersectionKHR => void,
            .OpTerminateRayKHR => void,
            .OpSDot => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, packed_vector_format: ?PackedVectorFormat = null },
            .OpUDot => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, packed_vector_format: ?PackedVectorFormat = null },
            .OpSUDot => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, packed_vector_format: ?PackedVectorFormat = null },
            .OpSDotAccSat => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, accumulator: IdRef, packed_vector_format: ?PackedVectorFormat = null },
            .OpUDotAccSat => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, accumulator: IdRef, packed_vector_format: ?PackedVectorFormat = null },
            .OpSUDotAccSat => struct { id_result_type: IdResultType, id_result: IdResult, vector_1: IdRef, vector_2: IdRef, accumulator: IdRef, packed_vector_format: ?PackedVectorFormat = null },
            .OpTypeCooperativeMatrixKHR => struct { id_result: IdResult, component_type: IdRef, scope: IdScope, rows: IdRef, columns: IdRef, use: IdRef },
            .OpCooperativeMatrixLoadKHR => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memorylayout: IdRef, stride: ?IdRef = null, memory_operand: ?MemoryAccess.Extended = null },
            .OpCooperativeMatrixStoreKHR => struct { pointer: IdRef, object: IdRef, memorylayout: IdRef, stride: ?IdRef = null, memory_operand: ?MemoryAccess.Extended = null },
            .OpCooperativeMatrixMulAddKHR => struct { id_result_type: IdResultType, id_result: IdResult, a: IdRef, b: IdRef, c: IdRef, cooperative_matrix_operands: ?CooperativeMatrixOperands = null },
            .OpCooperativeMatrixLengthKHR => struct { id_result_type: IdResultType, id_result: IdResult, type: IdRef },
            .OpTypeRayQueryKHR => struct { id_result: IdResult },
            .OpRayQueryInitializeKHR => struct { rayquery: IdRef, accel: IdRef, rayflags: IdRef, cullmask: IdRef, rayorigin: IdRef, raytmin: IdRef, raydirection: IdRef, raytmax: IdRef },
            .OpRayQueryTerminateKHR => struct { rayquery: IdRef },
            .OpRayQueryGenerateIntersectionKHR => struct { rayquery: IdRef, hitt: IdRef },
            .OpRayQueryConfirmIntersectionKHR => struct { rayquery: IdRef },
            .OpRayQueryProceedKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef },
            .OpRayQueryGetIntersectionTypeKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpImageSampleWeightedQCOM => struct { id_result_type: IdResultType, id_result: IdResult, texture: IdRef, coordinates: IdRef, weights: IdRef },
            .OpImageBoxFilterQCOM => struct { id_result_type: IdResultType, id_result: IdResult, texture: IdRef, coordinates: IdRef, box_size: IdRef },
            .OpImageBlockMatchSSDQCOM => struct { id_result_type: IdResultType, id_result: IdResult, target: IdRef, target_coordinates: IdRef, reference: IdRef, reference_coordinates: IdRef, block_size: IdRef },
            .OpImageBlockMatchSADQCOM => struct { id_result_type: IdResultType, id_result: IdResult, target: IdRef, target_coordinates: IdRef, reference: IdRef, reference_coordinates: IdRef, block_size: IdRef },
            .OpImageBlockMatchWindowSSDQCOM => struct { id_result_type: IdResultType, id_result: IdResult, target_sampled_image: IdRef, target_coordinates: IdRef, reference_sampled_image: IdRef, reference_coordinates: IdRef, block_size: IdRef },
            .OpImageBlockMatchWindowSADQCOM => struct { id_result_type: IdResultType, id_result: IdResult, target_sampled_image: IdRef, target_coordinates: IdRef, reference_sampled_image: IdRef, reference_coordinates: IdRef, block_size: IdRef },
            .OpImageBlockMatchGatherSSDQCOM => struct { id_result_type: IdResultType, id_result: IdResult, target_sampled_image: IdRef, target_coordinates: IdRef, reference_sampled_image: IdRef, reference_coordinates: IdRef, block_size: IdRef },
            .OpImageBlockMatchGatherSADQCOM => struct { id_result_type: IdResultType, id_result: IdResult, target_sampled_image: IdRef, target_coordinates: IdRef, reference_sampled_image: IdRef, reference_coordinates: IdRef, block_size: IdRef },
            .OpGroupIAddNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFAddNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFMinNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupUMinNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupSMinNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFMaxNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupUMaxNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupSMaxNonUniformAMD => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpFragmentMaskFetchAMD => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef },
            .OpFragmentFetchAMD => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, fragment_index: IdRef },
            .OpReadClockKHR => struct { id_result_type: IdResultType, id_result: IdResult, scope: IdScope },
            .OpFinalizeNodePayloadsAMDX => struct { payload_array: IdRef },
            .OpFinishWritingNodePayloadAMDX => struct { id_result_type: IdResultType, id_result: IdResult, payload: IdRef },
            .OpInitializeNodePayloadsAMDX => struct { payload_array: IdRef, visibility: IdScope, payload_count: IdRef, node_index: IdRef },
            .OpGroupNonUniformQuadAllKHR => struct { id_result_type: IdResultType, id_result: IdResult, predicate: IdRef },
            .OpGroupNonUniformQuadAnyKHR => struct { id_result_type: IdResultType, id_result: IdResult, predicate: IdRef },
            .OpHitObjectRecordHitMotionNV => struct { hit_object: IdRef, acceleration_structure: IdRef, instanceid: IdRef, primitiveid: IdRef, geometryindex: IdRef, hit_kind: IdRef, sbt_record_offset: IdRef, sbt_record_stride: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, current_time: IdRef, hitobject_attributes: IdRef },
            .OpHitObjectRecordHitWithIndexMotionNV => struct { hit_object: IdRef, acceleration_structure: IdRef, instanceid: IdRef, primitiveid: IdRef, geometryindex: IdRef, hit_kind: IdRef, sbt_record_index: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, current_time: IdRef, hitobject_attributes: IdRef },
            .OpHitObjectRecordMissMotionNV => struct { hit_object: IdRef, sbt_index: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, current_time: IdRef },
            .OpHitObjectGetWorldToObjectNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetObjectToWorldNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetObjectRayDirectionNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetObjectRayOriginNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectTraceRayMotionNV => struct { hit_object: IdRef, acceleration_structure: IdRef, rayflags: IdRef, cullmask: IdRef, sbt_record_offset: IdRef, sbt_record_stride: IdRef, miss_index: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, time: IdRef, payload: IdRef },
            .OpHitObjectGetShaderRecordBufferHandleNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetShaderBindingTableRecordIndexNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectRecordEmptyNV => struct { hit_object: IdRef },
            .OpHitObjectTraceRayNV => struct { hit_object: IdRef, acceleration_structure: IdRef, rayflags: IdRef, cullmask: IdRef, sbt_record_offset: IdRef, sbt_record_stride: IdRef, miss_index: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, payload: IdRef },
            .OpHitObjectRecordHitNV => struct { hit_object: IdRef, acceleration_structure: IdRef, instanceid: IdRef, primitiveid: IdRef, geometryindex: IdRef, hit_kind: IdRef, sbt_record_offset: IdRef, sbt_record_stride: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, hitobject_attributes: IdRef },
            .OpHitObjectRecordHitWithIndexNV => struct { hit_object: IdRef, acceleration_structure: IdRef, instanceid: IdRef, primitiveid: IdRef, geometryindex: IdRef, hit_kind: IdRef, sbt_record_index: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef, hitobject_attributes: IdRef },
            .OpHitObjectRecordMissNV => struct { hit_object: IdRef, sbt_index: IdRef, origin: IdRef, tmin: IdRef, direction: IdRef, tmax: IdRef },
            .OpHitObjectExecuteShaderNV => struct { hit_object: IdRef, payload: IdRef },
            .OpHitObjectGetCurrentTimeNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetAttributesNV => struct { hit_object: IdRef, hit_object_attribute: IdRef },
            .OpHitObjectGetHitKindNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetPrimitiveIndexNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetGeometryIndexNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetInstanceIdNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetInstanceCustomIndexNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetWorldRayDirectionNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetWorldRayOriginNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetRayTMaxNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectGetRayTMinNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectIsEmptyNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectIsHitNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpHitObjectIsMissNV => struct { id_result_type: IdResultType, id_result: IdResult, hit_object: IdRef },
            .OpReorderThreadWithHitObjectNV => struct { hit_object: IdRef, hint: ?IdRef = null, bits: ?IdRef = null },
            .OpReorderThreadWithHintNV => struct { hint: IdRef, bits: IdRef },
            .OpTypeHitObjectNV => struct { id_result: IdResult },
            .OpImageSampleFootprintNV => struct { id_result_type: IdResultType, id_result: IdResult, sampled_image: IdRef, coordinate: IdRef, granularity: IdRef, coarse: IdRef, image_operands: ?ImageOperands.Extended = null },
            .OpEmitMeshTasksEXT => struct { group_count_x: IdRef, group_count_y: IdRef, group_count_z: IdRef, payload: ?IdRef = null },
            .OpSetMeshOutputsEXT => struct { vertex_count: IdRef, primitive_count: IdRef },
            .OpGroupNonUniformPartitionNV => struct { id_result_type: IdResultType, id_result: IdResult, value: IdRef },
            .OpWritePackedPrimitiveIndices4x8NV => struct { index_offset: IdRef, packed_indices: IdRef },
            .OpFetchMicroTriangleVertexPositionNV => struct { id_result_type: IdResultType, id_result: IdResult, accel: IdRef, instance_id: IdRef, geometry_index: IdRef, primitive_index: IdRef, barycentric: IdRef },
            .OpFetchMicroTriangleVertexBarycentricNV => struct { id_result_type: IdResultType, id_result: IdResult, accel: IdRef, instance_id: IdRef, geometry_index: IdRef, primitive_index: IdRef, barycentric: IdRef },
            .OpReportIntersectionKHR => struct { id_result_type: IdResultType, id_result: IdResult, hit: IdRef, hitkind: IdRef },
            .OpIgnoreIntersectionNV => void,
            .OpTerminateRayNV => void,
            .OpTraceNV => struct { accel: IdRef, ray_flags: IdRef, cull_mask: IdRef, sbt_offset: IdRef, sbt_stride: IdRef, miss_index: IdRef, ray_origin: IdRef, ray_tmin: IdRef, ray_direction: IdRef, ray_tmax: IdRef, payloadid: IdRef },
            .OpTraceMotionNV => struct { accel: IdRef, ray_flags: IdRef, cull_mask: IdRef, sbt_offset: IdRef, sbt_stride: IdRef, miss_index: IdRef, ray_origin: IdRef, ray_tmin: IdRef, ray_direction: IdRef, ray_tmax: IdRef, time: IdRef, payloadid: IdRef },
            .OpTraceRayMotionNV => struct { accel: IdRef, ray_flags: IdRef, cull_mask: IdRef, sbt_offset: IdRef, sbt_stride: IdRef, miss_index: IdRef, ray_origin: IdRef, ray_tmin: IdRef, ray_direction: IdRef, ray_tmax: IdRef, time: IdRef, payload: IdRef },
            .OpRayQueryGetIntersectionTriangleVertexPositionsKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpTypeAccelerationStructureKHR => struct { id_result: IdResult },
            .OpExecuteCallableNV => struct { sbt_index: IdRef, callable_dataid: IdRef },
            .OpTypeCooperativeMatrixNV => struct { id_result: IdResult, component_type: IdRef, execution: IdScope, rows: IdRef, columns: IdRef },
            .OpCooperativeMatrixLoadNV => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, stride: IdRef, column_major: IdRef, memory_access: ?MemoryAccess.Extended = null },
            .OpCooperativeMatrixStoreNV => struct { pointer: IdRef, object: IdRef, stride: IdRef, column_major: IdRef, memory_access: ?MemoryAccess.Extended = null },
            .OpCooperativeMatrixMulAddNV => struct { id_result_type: IdResultType, id_result: IdResult, a: IdRef, b: IdRef, c: IdRef },
            .OpCooperativeMatrixLengthNV => struct { id_result_type: IdResultType, id_result: IdResult, type: IdRef },
            .OpBeginInvocationInterlockEXT => void,
            .OpEndInvocationInterlockEXT => void,
            .OpDemoteToHelperInvocation => void,
            .OpIsHelperInvocationEXT => struct { id_result_type: IdResultType, id_result: IdResult },
            .OpConvertUToImageNV => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpConvertUToSamplerNV => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpConvertImageToUNV => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpConvertSamplerToUNV => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpConvertUToSampledImageNV => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpConvertSampledImageToUNV => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpSamplerImageAddressingModeNV => struct { bit_width: LiteralInteger },
            .OpRawAccessChainNV => struct { id_result_type: IdResultType, id_result: IdResult, base: IdRef, byte_stride: IdRef, element_index: IdRef, byte_offset: IdRef, raw_access_chain_operands: ?RawAccessChainOperands = null },
            .OpSubgroupShuffleINTEL => struct { id_result_type: IdResultType, id_result: IdResult, data: IdRef, invocationid: IdRef },
            .OpSubgroupShuffleDownINTEL => struct { id_result_type: IdResultType, id_result: IdResult, current: IdRef, next: IdRef, delta: IdRef },
            .OpSubgroupShuffleUpINTEL => struct { id_result_type: IdResultType, id_result: IdResult, previous: IdRef, current: IdRef, delta: IdRef },
            .OpSubgroupShuffleXorINTEL => struct { id_result_type: IdResultType, id_result: IdResult, data: IdRef, value: IdRef },
            .OpSubgroupBlockReadINTEL => struct { id_result_type: IdResultType, id_result: IdResult, ptr: IdRef },
            .OpSubgroupBlockWriteINTEL => struct { ptr: IdRef, data: IdRef },
            .OpSubgroupImageBlockReadINTEL => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef },
            .OpSubgroupImageBlockWriteINTEL => struct { image: IdRef, coordinate: IdRef, data: IdRef },
            .OpSubgroupImageMediaBlockReadINTEL => struct { id_result_type: IdResultType, id_result: IdResult, image: IdRef, coordinate: IdRef, width: IdRef, height: IdRef },
            .OpSubgroupImageMediaBlockWriteINTEL => struct { image: IdRef, coordinate: IdRef, width: IdRef, height: IdRef, data: IdRef },
            .OpUCountLeadingZerosINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpUCountTrailingZerosINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand: IdRef },
            .OpAbsISubINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpAbsUSubINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpIAddSatINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUAddSatINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpIAverageINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUAverageINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpIAverageRoundedINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUAverageRoundedINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpISubSatINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUSubSatINTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpIMul32x16INTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpUMul32x16INTEL => struct { id_result_type: IdResultType, id_result: IdResult, operand_1: IdRef, operand_2: IdRef },
            .OpAtomicFMinEXT => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAtomicFMaxEXT => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpAssumeTrueKHR => struct { condition: IdRef },
            .OpExpectKHR => struct { id_result_type: IdResultType, id_result: IdResult, value: IdRef, expectedvalue: IdRef },
            .OpDecorateString => struct { target: IdRef, decoration: Decoration.Extended },
            .OpMemberDecorateString => struct { struct_type: IdRef, member: LiteralInteger, decoration: Decoration.Extended },
            .OpLoopControlINTEL => struct { loop_control_parameters: []const LiteralInteger = &.{} },
            .OpReadPipeBlockingINTEL => struct { id_result_type: IdResultType, id_result: IdResult, packet_size: IdRef, packet_alignment: IdRef },
            .OpWritePipeBlockingINTEL => struct { id_result_type: IdResultType, id_result: IdResult, packet_size: IdRef, packet_alignment: IdRef },
            .OpFPGARegINTEL => struct { id_result_type: IdResultType, id_result: IdResult, result: IdRef, input: IdRef },
            .OpRayQueryGetRayTMinKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef },
            .OpRayQueryGetRayFlagsKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef },
            .OpRayQueryGetIntersectionTKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionInstanceCustomIndexKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionInstanceIdKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionGeometryIndexKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionPrimitiveIndexKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionBarycentricsKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionFrontFaceKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionCandidateAABBOpaqueKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef },
            .OpRayQueryGetIntersectionObjectRayDirectionKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionObjectRayOriginKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetWorldRayDirectionKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef },
            .OpRayQueryGetWorldRayOriginKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef },
            .OpRayQueryGetIntersectionObjectToWorldKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpRayQueryGetIntersectionWorldToObjectKHR => struct { id_result_type: IdResultType, id_result: IdResult, rayquery: IdRef, intersection: IdRef },
            .OpAtomicFAddEXT => struct { id_result_type: IdResultType, id_result: IdResult, pointer: IdRef, memory: IdScope, semantics: IdMemorySemantics, value: IdRef },
            .OpTypeBufferSurfaceINTEL => struct { id_result: IdResult, accessqualifier: AccessQualifier },
            .OpTypeStructContinuedINTEL => struct { id_ref: []const IdRef = &.{} },
            .OpConstantCompositeContinuedINTEL => struct { constituents: []const IdRef = &.{} },
            .OpSpecConstantCompositeContinuedINTEL => struct { constituents: []const IdRef = &.{} },
            .OpCompositeConstructContinuedINTEL => struct { id_result_type: IdResultType, id_result: IdResult, constituents: []const IdRef = &.{} },
            .OpConvertFToBF16INTEL => struct { id_result_type: IdResultType, id_result: IdResult, float_value: IdRef },
            .OpConvertBF16ToFINTEL => struct { id_result_type: IdResultType, id_result: IdResult, bfloat16_value: IdRef },
            .OpControlBarrierArriveINTEL => struct { execution: IdScope, memory: IdScope, semantics: IdMemorySemantics },
            .OpControlBarrierWaitINTEL => struct { execution: IdScope, memory: IdScope, semantics: IdMemorySemantics },
            .OpGroupIMulKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupFMulKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupBitwiseAndKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupBitwiseOrKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupBitwiseXorKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupLogicalAndKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupLogicalOrKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpGroupLogicalXorKHR => struct { id_result_type: IdResultType, id_result: IdResult, execution: IdScope, operation: GroupOperation, x: IdRef },
            .OpMaskedGatherINTEL => struct { id_result_type: IdResultType, id_result: IdResult, ptrvector: IdRef, alignment: LiteralInteger, mask: IdRef, fillempty: IdRef },
            .OpMaskedScatterINTEL => struct { inputvector: IdRef, ptrvector: IdRef, alignment: LiteralInteger, mask: IdRef },
        };
    }
    pub fn class(self: Opcode) Class {
        return switch (self) {
            .OpNop => .Miscellaneous,
            .OpUndef => .Miscellaneous,
            .OpSourceContinued => .Debug,
            .OpSource => .Debug,
            .OpSourceExtension => .Debug,
            .OpName => .Debug,
            .OpMemberName => .Debug,
            .OpString => .Debug,
            .OpLine => .Debug,
            .OpExtension => .Extension,
            .OpExtInstImport => .Extension,
            .OpExtInst => .Extension,
            .OpMemoryModel => .ModeSetting,
            .OpEntryPoint => .ModeSetting,
            .OpExecutionMode => .ModeSetting,
            .OpCapability => .ModeSetting,
            .OpTypeVoid => .TypeDeclaration,
            .OpTypeBool => .TypeDeclaration,
            .OpTypeInt => .TypeDeclaration,
            .OpTypeFloat => .TypeDeclaration,
            .OpTypeVector => .TypeDeclaration,
            .OpTypeMatrix => .TypeDeclaration,
            .OpTypeImage => .TypeDeclaration,
            .OpTypeSampler => .TypeDeclaration,
            .OpTypeSampledImage => .TypeDeclaration,
            .OpTypeArray => .TypeDeclaration,
            .OpTypeRuntimeArray => .TypeDeclaration,
            .OpTypeStruct => .TypeDeclaration,
            .OpTypeOpaque => .TypeDeclaration,
            .OpTypePointer => .TypeDeclaration,
            .OpTypeFunction => .TypeDeclaration,
            .OpTypeEvent => .TypeDeclaration,
            .OpTypeDeviceEvent => .TypeDeclaration,
            .OpTypeReserveId => .TypeDeclaration,
            .OpTypeQueue => .TypeDeclaration,
            .OpTypePipe => .TypeDeclaration,
            .OpTypeForwardPointer => .TypeDeclaration,
            .OpConstantTrue => .ConstantCreation,
            .OpConstantFalse => .ConstantCreation,
            .OpConstant => .ConstantCreation,
            .OpConstantComposite => .ConstantCreation,
            .OpConstantSampler => .ConstantCreation,
            .OpConstantNull => .ConstantCreation,
            .OpSpecConstantTrue => .ConstantCreation,
            .OpSpecConstantFalse => .ConstantCreation,
            .OpSpecConstant => .ConstantCreation,
            .OpSpecConstantComposite => .ConstantCreation,
            .OpSpecConstantOp => .ConstantCreation,
            .OpFunction => .Function,
            .OpFunctionParameter => .Function,
            .OpFunctionEnd => .Function,
            .OpFunctionCall => .Function,
            .OpVariable => .Memory,
            .OpImageTexelPointer => .Memory,
            .OpLoad => .Memory,
            .OpStore => .Memory,
            .OpCopyMemory => .Memory,
            .OpCopyMemorySized => .Memory,
            .OpAccessChain => .Memory,
            .OpInBoundsAccessChain => .Memory,
            .OpPtrAccessChain => .Memory,
            .OpArrayLength => .Memory,
            .OpGenericPtrMemSemantics => .Memory,
            .OpInBoundsPtrAccessChain => .Memory,
            .OpDecorate => .Annotation,
            .OpMemberDecorate => .Annotation,
            .OpDecorationGroup => .Annotation,
            .OpGroupDecorate => .Annotation,
            .OpGroupMemberDecorate => .Annotation,
            .OpVectorExtractDynamic => .Composite,
            .OpVectorInsertDynamic => .Composite,
            .OpVectorShuffle => .Composite,
            .OpCompositeConstruct => .Composite,
            .OpCompositeExtract => .Composite,
            .OpCompositeInsert => .Composite,
            .OpCopyObject => .Composite,
            .OpTranspose => .Composite,
            .OpSampledImage => .Image,
            .OpImageSampleImplicitLod => .Image,
            .OpImageSampleExplicitLod => .Image,
            .OpImageSampleDrefImplicitLod => .Image,
            .OpImageSampleDrefExplicitLod => .Image,
            .OpImageSampleProjImplicitLod => .Image,
            .OpImageSampleProjExplicitLod => .Image,
            .OpImageSampleProjDrefImplicitLod => .Image,
            .OpImageSampleProjDrefExplicitLod => .Image,
            .OpImageFetch => .Image,
            .OpImageGather => .Image,
            .OpImageDrefGather => .Image,
            .OpImageRead => .Image,
            .OpImageWrite => .Image,
            .OpImage => .Image,
            .OpImageQueryFormat => .Image,
            .OpImageQueryOrder => .Image,
            .OpImageQuerySizeLod => .Image,
            .OpImageQuerySize => .Image,
            .OpImageQueryLod => .Image,
            .OpImageQueryLevels => .Image,
            .OpImageQuerySamples => .Image,
            .OpConvertFToU => .Conversion,
            .OpConvertFToS => .Conversion,
            .OpConvertSToF => .Conversion,
            .OpConvertUToF => .Conversion,
            .OpUConvert => .Conversion,
            .OpSConvert => .Conversion,
            .OpFConvert => .Conversion,
            .OpQuantizeToF16 => .Conversion,
            .OpConvertPtrToU => .Conversion,
            .OpSatConvertSToU => .Conversion,
            .OpSatConvertUToS => .Conversion,
            .OpConvertUToPtr => .Conversion,
            .OpPtrCastToGeneric => .Conversion,
            .OpGenericCastToPtr => .Conversion,
            .OpGenericCastToPtrExplicit => .Conversion,
            .OpBitcast => .Conversion,
            .OpSNegate => .Arithmetic,
            .OpFNegate => .Arithmetic,
            .OpIAdd => .Arithmetic,
            .OpFAdd => .Arithmetic,
            .OpISub => .Arithmetic,
            .OpFSub => .Arithmetic,
            .OpIMul => .Arithmetic,
            .OpFMul => .Arithmetic,
            .OpUDiv => .Arithmetic,
            .OpSDiv => .Arithmetic,
            .OpFDiv => .Arithmetic,
            .OpUMod => .Arithmetic,
            .OpSRem => .Arithmetic,
            .OpSMod => .Arithmetic,
            .OpFRem => .Arithmetic,
            .OpFMod => .Arithmetic,
            .OpVectorTimesScalar => .Arithmetic,
            .OpMatrixTimesScalar => .Arithmetic,
            .OpVectorTimesMatrix => .Arithmetic,
            .OpMatrixTimesVector => .Arithmetic,
            .OpMatrixTimesMatrix => .Arithmetic,
            .OpOuterProduct => .Arithmetic,
            .OpDot => .Arithmetic,
            .OpIAddCarry => .Arithmetic,
            .OpISubBorrow => .Arithmetic,
            .OpUMulExtended => .Arithmetic,
            .OpSMulExtended => .Arithmetic,
            .OpAny => .RelationalAndLogical,
            .OpAll => .RelationalAndLogical,
            .OpIsNan => .RelationalAndLogical,
            .OpIsInf => .RelationalAndLogical,
            .OpIsFinite => .RelationalAndLogical,
            .OpIsNormal => .RelationalAndLogical,
            .OpSignBitSet => .RelationalAndLogical,
            .OpLessOrGreater => .RelationalAndLogical,
            .OpOrdered => .RelationalAndLogical,
            .OpUnordered => .RelationalAndLogical,
            .OpLogicalEqual => .RelationalAndLogical,
            .OpLogicalNotEqual => .RelationalAndLogical,
            .OpLogicalOr => .RelationalAndLogical,
            .OpLogicalAnd => .RelationalAndLogical,
            .OpLogicalNot => .RelationalAndLogical,
            .OpSelect => .RelationalAndLogical,
            .OpIEqual => .RelationalAndLogical,
            .OpINotEqual => .RelationalAndLogical,
            .OpUGreaterThan => .RelationalAndLogical,
            .OpSGreaterThan => .RelationalAndLogical,
            .OpUGreaterThanEqual => .RelationalAndLogical,
            .OpSGreaterThanEqual => .RelationalAndLogical,
            .OpULessThan => .RelationalAndLogical,
            .OpSLessThan => .RelationalAndLogical,
            .OpULessThanEqual => .RelationalAndLogical,
            .OpSLessThanEqual => .RelationalAndLogical,
            .OpFOrdEqual => .RelationalAndLogical,
            .OpFUnordEqual => .RelationalAndLogical,
            .OpFOrdNotEqual => .RelationalAndLogical,
            .OpFUnordNotEqual => .RelationalAndLogical,
            .OpFOrdLessThan => .RelationalAndLogical,
            .OpFUnordLessThan => .RelationalAndLogical,
            .OpFOrdGreaterThan => .RelationalAndLogical,
            .OpFUnordGreaterThan => .RelationalAndLogical,
            .OpFOrdLessThanEqual => .RelationalAndLogical,
            .OpFUnordLessThanEqual => .RelationalAndLogical,
            .OpFOrdGreaterThanEqual => .RelationalAndLogical,
            .OpFUnordGreaterThanEqual => .RelationalAndLogical,
            .OpShiftRightLogical => .Bit,
            .OpShiftRightArithmetic => .Bit,
            .OpShiftLeftLogical => .Bit,
            .OpBitwiseOr => .Bit,
            .OpBitwiseXor => .Bit,
            .OpBitwiseAnd => .Bit,
            .OpNot => .Bit,
            .OpBitFieldInsert => .Bit,
            .OpBitFieldSExtract => .Bit,
            .OpBitFieldUExtract => .Bit,
            .OpBitReverse => .Bit,
            .OpBitCount => .Bit,
            .OpDPdx => .Derivative,
            .OpDPdy => .Derivative,
            .OpFwidth => .Derivative,
            .OpDPdxFine => .Derivative,
            .OpDPdyFine => .Derivative,
            .OpFwidthFine => .Derivative,
            .OpDPdxCoarse => .Derivative,
            .OpDPdyCoarse => .Derivative,
            .OpFwidthCoarse => .Derivative,
            .OpEmitVertex => .Primitive,
            .OpEndPrimitive => .Primitive,
            .OpEmitStreamVertex => .Primitive,
            .OpEndStreamPrimitive => .Primitive,
            .OpControlBarrier => .Barrier,
            .OpMemoryBarrier => .Barrier,
            .OpAtomicLoad => .Atomic,
            .OpAtomicStore => .Atomic,
            .OpAtomicExchange => .Atomic,
            .OpAtomicCompareExchange => .Atomic,
            .OpAtomicCompareExchangeWeak => .Atomic,
            .OpAtomicIIncrement => .Atomic,
            .OpAtomicIDecrement => .Atomic,
            .OpAtomicIAdd => .Atomic,
            .OpAtomicISub => .Atomic,
            .OpAtomicSMin => .Atomic,
            .OpAtomicUMin => .Atomic,
            .OpAtomicSMax => .Atomic,
            .OpAtomicUMax => .Atomic,
            .OpAtomicAnd => .Atomic,
            .OpAtomicOr => .Atomic,
            .OpAtomicXor => .Atomic,
            .OpPhi => .ControlFlow,
            .OpLoopMerge => .ControlFlow,
            .OpSelectionMerge => .ControlFlow,
            .OpLabel => .ControlFlow,
            .OpBranch => .ControlFlow,
            .OpBranchConditional => .ControlFlow,
            .OpSwitch => .ControlFlow,
            .OpKill => .ControlFlow,
            .OpReturn => .ControlFlow,
            .OpReturnValue => .ControlFlow,
            .OpUnreachable => .ControlFlow,
            .OpLifetimeStart => .ControlFlow,
            .OpLifetimeStop => .ControlFlow,
            .OpGroupAsyncCopy => .Group,
            .OpGroupWaitEvents => .Group,
            .OpGroupAll => .Group,
            .OpGroupAny => .Group,
            .OpGroupBroadcast => .Group,
            .OpGroupIAdd => .Group,
            .OpGroupFAdd => .Group,
            .OpGroupFMin => .Group,
            .OpGroupUMin => .Group,
            .OpGroupSMin => .Group,
            .OpGroupFMax => .Group,
            .OpGroupUMax => .Group,
            .OpGroupSMax => .Group,
            .OpReadPipe => .Pipe,
            .OpWritePipe => .Pipe,
            .OpReservedReadPipe => .Pipe,
            .OpReservedWritePipe => .Pipe,
            .OpReserveReadPipePackets => .Pipe,
            .OpReserveWritePipePackets => .Pipe,
            .OpCommitReadPipe => .Pipe,
            .OpCommitWritePipe => .Pipe,
            .OpIsValidReserveId => .Pipe,
            .OpGetNumPipePackets => .Pipe,
            .OpGetMaxPipePackets => .Pipe,
            .OpGroupReserveReadPipePackets => .Pipe,
            .OpGroupReserveWritePipePackets => .Pipe,
            .OpGroupCommitReadPipe => .Pipe,
            .OpGroupCommitWritePipe => .Pipe,
            .OpEnqueueMarker => .DeviceSideEnqueue,
            .OpEnqueueKernel => .DeviceSideEnqueue,
            .OpGetKernelNDrangeSubGroupCount => .DeviceSideEnqueue,
            .OpGetKernelNDrangeMaxSubGroupSize => .DeviceSideEnqueue,
            .OpGetKernelWorkGroupSize => .DeviceSideEnqueue,
            .OpGetKernelPreferredWorkGroupSizeMultiple => .DeviceSideEnqueue,
            .OpRetainEvent => .DeviceSideEnqueue,
            .OpReleaseEvent => .DeviceSideEnqueue,
            .OpCreateUserEvent => .DeviceSideEnqueue,
            .OpIsValidEvent => .DeviceSideEnqueue,
            .OpSetUserEventStatus => .DeviceSideEnqueue,
            .OpCaptureEventProfilingInfo => .DeviceSideEnqueue,
            .OpGetDefaultQueue => .DeviceSideEnqueue,
            .OpBuildNDRange => .DeviceSideEnqueue,
            .OpImageSparseSampleImplicitLod => .Image,
            .OpImageSparseSampleExplicitLod => .Image,
            .OpImageSparseSampleDrefImplicitLod => .Image,
            .OpImageSparseSampleDrefExplicitLod => .Image,
            .OpImageSparseSampleProjImplicitLod => .Image,
            .OpImageSparseSampleProjExplicitLod => .Image,
            .OpImageSparseSampleProjDrefImplicitLod => .Image,
            .OpImageSparseSampleProjDrefExplicitLod => .Image,
            .OpImageSparseFetch => .Image,
            .OpImageSparseGather => .Image,
            .OpImageSparseDrefGather => .Image,
            .OpImageSparseTexelsResident => .Image,
            .OpNoLine => .Debug,
            .OpAtomicFlagTestAndSet => .Atomic,
            .OpAtomicFlagClear => .Atomic,
            .OpImageSparseRead => .Image,
            .OpSizeOf => .Miscellaneous,
            .OpTypePipeStorage => .TypeDeclaration,
            .OpConstantPipeStorage => .Pipe,
            .OpCreatePipeFromPipeStorage => .Pipe,
            .OpGetKernelLocalSizeForSubgroupCount => .DeviceSideEnqueue,
            .OpGetKernelMaxNumSubgroups => .DeviceSideEnqueue,
            .OpTypeNamedBarrier => .TypeDeclaration,
            .OpNamedBarrierInitialize => .Barrier,
            .OpMemoryNamedBarrier => .Barrier,
            .OpModuleProcessed => .Debug,
            .OpExecutionModeId => .ModeSetting,
            .OpDecorateId => .Annotation,
            .OpGroupNonUniformElect => .NonUniform,
            .OpGroupNonUniformAll => .NonUniform,
            .OpGroupNonUniformAny => .NonUniform,
            .OpGroupNonUniformAllEqual => .NonUniform,
            .OpGroupNonUniformBroadcast => .NonUniform,
            .OpGroupNonUniformBroadcastFirst => .NonUniform,
            .OpGroupNonUniformBallot => .NonUniform,
            .OpGroupNonUniformInverseBallot => .NonUniform,
            .OpGroupNonUniformBallotBitExtract => .NonUniform,
            .OpGroupNonUniformBallotBitCount => .NonUniform,
            .OpGroupNonUniformBallotFindLSB => .NonUniform,
            .OpGroupNonUniformBallotFindMSB => .NonUniform,
            .OpGroupNonUniformShuffle => .NonUniform,
            .OpGroupNonUniformShuffleXor => .NonUniform,
            .OpGroupNonUniformShuffleUp => .NonUniform,
            .OpGroupNonUniformShuffleDown => .NonUniform,
            .OpGroupNonUniformIAdd => .NonUniform,
            .OpGroupNonUniformFAdd => .NonUniform,
            .OpGroupNonUniformIMul => .NonUniform,
            .OpGroupNonUniformFMul => .NonUniform,
            .OpGroupNonUniformSMin => .NonUniform,
            .OpGroupNonUniformUMin => .NonUniform,
            .OpGroupNonUniformFMin => .NonUniform,
            .OpGroupNonUniformSMax => .NonUniform,
            .OpGroupNonUniformUMax => .NonUniform,
            .OpGroupNonUniformFMax => .NonUniform,
            .OpGroupNonUniformBitwiseAnd => .NonUniform,
            .OpGroupNonUniformBitwiseOr => .NonUniform,
            .OpGroupNonUniformBitwiseXor => .NonUniform,
            .OpGroupNonUniformLogicalAnd => .NonUniform,
            .OpGroupNonUniformLogicalOr => .NonUniform,
            .OpGroupNonUniformLogicalXor => .NonUniform,
            .OpGroupNonUniformQuadBroadcast => .NonUniform,
            .OpGroupNonUniformQuadSwap => .NonUniform,
            .OpCopyLogical => .Composite,
            .OpPtrEqual => .Memory,
            .OpPtrNotEqual => .Memory,
            .OpPtrDiff => .Memory,
            .OpColorAttachmentReadEXT => .Image,
            .OpDepthAttachmentReadEXT => .Image,
            .OpStencilAttachmentReadEXT => .Image,
            .OpTerminateInvocation => .ControlFlow,
            .OpSubgroupBallotKHR => .Group,
            .OpSubgroupFirstInvocationKHR => .Group,
            .OpSubgroupAllKHR => .Group,
            .OpSubgroupAnyKHR => .Group,
            .OpSubgroupAllEqualKHR => .Group,
            .OpGroupNonUniformRotateKHR => .Group,
            .OpSubgroupReadInvocationKHR => .Group,
            .OpTraceRayKHR => .Reserved,
            .OpExecuteCallableKHR => .Reserved,
            .OpConvertUToAccelerationStructureKHR => .Reserved,
            .OpIgnoreIntersectionKHR => .Reserved,
            .OpTerminateRayKHR => .Reserved,
            .OpSDot => .Arithmetic,
            .OpUDot => .Arithmetic,
            .OpSUDot => .Arithmetic,
            .OpSDotAccSat => .Arithmetic,
            .OpUDotAccSat => .Arithmetic,
            .OpSUDotAccSat => .Arithmetic,
            .OpTypeCooperativeMatrixKHR => .TypeDeclaration,
            .OpCooperativeMatrixLoadKHR => .Memory,
            .OpCooperativeMatrixStoreKHR => .Memory,
            .OpCooperativeMatrixMulAddKHR => .Arithmetic,
            .OpCooperativeMatrixLengthKHR => .Miscellaneous,
            .OpTypeRayQueryKHR => .TypeDeclaration,
            .OpRayQueryInitializeKHR => .Reserved,
            .OpRayQueryTerminateKHR => .Reserved,
            .OpRayQueryGenerateIntersectionKHR => .Reserved,
            .OpRayQueryConfirmIntersectionKHR => .Reserved,
            .OpRayQueryProceedKHR => .Reserved,
            .OpRayQueryGetIntersectionTypeKHR => .Reserved,
            .OpImageSampleWeightedQCOM => .Image,
            .OpImageBoxFilterQCOM => .Image,
            .OpImageBlockMatchSSDQCOM => .Image,
            .OpImageBlockMatchSADQCOM => .Image,
            .OpImageBlockMatchWindowSSDQCOM => .Image,
            .OpImageBlockMatchWindowSADQCOM => .Image,
            .OpImageBlockMatchGatherSSDQCOM => .Image,
            .OpImageBlockMatchGatherSADQCOM => .Image,
            .OpGroupIAddNonUniformAMD => .Group,
            .OpGroupFAddNonUniformAMD => .Group,
            .OpGroupFMinNonUniformAMD => .Group,
            .OpGroupUMinNonUniformAMD => .Group,
            .OpGroupSMinNonUniformAMD => .Group,
            .OpGroupFMaxNonUniformAMD => .Group,
            .OpGroupUMaxNonUniformAMD => .Group,
            .OpGroupSMaxNonUniformAMD => .Group,
            .OpFragmentMaskFetchAMD => .Reserved,
            .OpFragmentFetchAMD => .Reserved,
            .OpReadClockKHR => .Reserved,
            .OpFinalizeNodePayloadsAMDX => .Reserved,
            .OpFinishWritingNodePayloadAMDX => .Reserved,
            .OpInitializeNodePayloadsAMDX => .Reserved,
            .OpGroupNonUniformQuadAllKHR => .NonUniform,
            .OpGroupNonUniformQuadAnyKHR => .NonUniform,
            .OpHitObjectRecordHitMotionNV => .Reserved,
            .OpHitObjectRecordHitWithIndexMotionNV => .Reserved,
            .OpHitObjectRecordMissMotionNV => .Reserved,
            .OpHitObjectGetWorldToObjectNV => .Reserved,
            .OpHitObjectGetObjectToWorldNV => .Reserved,
            .OpHitObjectGetObjectRayDirectionNV => .Reserved,
            .OpHitObjectGetObjectRayOriginNV => .Reserved,
            .OpHitObjectTraceRayMotionNV => .Reserved,
            .OpHitObjectGetShaderRecordBufferHandleNV => .Reserved,
            .OpHitObjectGetShaderBindingTableRecordIndexNV => .Reserved,
            .OpHitObjectRecordEmptyNV => .Reserved,
            .OpHitObjectTraceRayNV => .Reserved,
            .OpHitObjectRecordHitNV => .Reserved,
            .OpHitObjectRecordHitWithIndexNV => .Reserved,
            .OpHitObjectRecordMissNV => .Reserved,
            .OpHitObjectExecuteShaderNV => .Reserved,
            .OpHitObjectGetCurrentTimeNV => .Reserved,
            .OpHitObjectGetAttributesNV => .Reserved,
            .OpHitObjectGetHitKindNV => .Reserved,
            .OpHitObjectGetPrimitiveIndexNV => .Reserved,
            .OpHitObjectGetGeometryIndexNV => .Reserved,
            .OpHitObjectGetInstanceIdNV => .Reserved,
            .OpHitObjectGetInstanceCustomIndexNV => .Reserved,
            .OpHitObjectGetWorldRayDirectionNV => .Reserved,
            .OpHitObjectGetWorldRayOriginNV => .Reserved,
            .OpHitObjectGetRayTMaxNV => .Reserved,
            .OpHitObjectGetRayTMinNV => .Reserved,
            .OpHitObjectIsEmptyNV => .Reserved,
            .OpHitObjectIsHitNV => .Reserved,
            .OpHitObjectIsMissNV => .Reserved,
            .OpReorderThreadWithHitObjectNV => .Reserved,
            .OpReorderThreadWithHintNV => .Reserved,
            .OpTypeHitObjectNV => .TypeDeclaration,
            .OpImageSampleFootprintNV => .Image,
            .OpEmitMeshTasksEXT => .Reserved,
            .OpSetMeshOutputsEXT => .Reserved,
            .OpGroupNonUniformPartitionNV => .NonUniform,
            .OpWritePackedPrimitiveIndices4x8NV => .Reserved,
            .OpFetchMicroTriangleVertexPositionNV => .Reserved,
            .OpFetchMicroTriangleVertexBarycentricNV => .Reserved,
            .OpReportIntersectionKHR => .Reserved,
            .OpIgnoreIntersectionNV => .Reserved,
            .OpTerminateRayNV => .Reserved,
            .OpTraceNV => .Reserved,
            .OpTraceMotionNV => .Reserved,
            .OpTraceRayMotionNV => .Reserved,
            .OpRayQueryGetIntersectionTriangleVertexPositionsKHR => .Reserved,
            .OpTypeAccelerationStructureKHR => .TypeDeclaration,
            .OpExecuteCallableNV => .Reserved,
            .OpTypeCooperativeMatrixNV => .TypeDeclaration,
            .OpCooperativeMatrixLoadNV => .Reserved,
            .OpCooperativeMatrixStoreNV => .Reserved,
            .OpCooperativeMatrixMulAddNV => .Reserved,
            .OpCooperativeMatrixLengthNV => .Reserved,
            .OpBeginInvocationInterlockEXT => .Reserved,
            .OpEndInvocationInterlockEXT => .Reserved,
            .OpDemoteToHelperInvocation => .ControlFlow,
            .OpIsHelperInvocationEXT => .Reserved,
            .OpConvertUToImageNV => .Reserved,
            .OpConvertUToSamplerNV => .Reserved,
            .OpConvertImageToUNV => .Reserved,
            .OpConvertSamplerToUNV => .Reserved,
            .OpConvertUToSampledImageNV => .Reserved,
            .OpConvertSampledImageToUNV => .Reserved,
            .OpSamplerImageAddressingModeNV => .Reserved,
            .OpRawAccessChainNV => .Memory,
            .OpSubgroupShuffleINTEL => .Group,
            .OpSubgroupShuffleDownINTEL => .Group,
            .OpSubgroupShuffleUpINTEL => .Group,
            .OpSubgroupShuffleXorINTEL => .Group,
            .OpSubgroupBlockReadINTEL => .Group,
            .OpSubgroupBlockWriteINTEL => .Group,
            .OpSubgroupImageBlockReadINTEL => .Group,
            .OpSubgroupImageBlockWriteINTEL => .Group,
            .OpSubgroupImageMediaBlockReadINTEL => .Group,
            .OpSubgroupImageMediaBlockWriteINTEL => .Group,
            .OpUCountLeadingZerosINTEL => .Reserved,
            .OpUCountTrailingZerosINTEL => .Reserved,
            .OpAbsISubINTEL => .Reserved,
            .OpAbsUSubINTEL => .Reserved,
            .OpIAddSatINTEL => .Reserved,
            .OpUAddSatINTEL => .Reserved,
            .OpIAverageINTEL => .Reserved,
            .OpUAverageINTEL => .Reserved,
            .OpIAverageRoundedINTEL => .Reserved,
            .OpUAverageRoundedINTEL => .Reserved,
            .OpISubSatINTEL => .Reserved,
            .OpUSubSatINTEL => .Reserved,
            .OpIMul32x16INTEL => .Reserved,
            .OpUMul32x16INTEL => .Reserved,
            .OpAtomicFMinEXT => .Atomic,
            .OpAtomicFMaxEXT => .Atomic,
            .OpAssumeTrueKHR => .Miscellaneous,
            .OpExpectKHR => .Miscellaneous,
            .OpDecorateString => .Annotation,
            .OpMemberDecorateString => .Annotation,
            .OpLoopControlINTEL => .Reserved,
            .OpReadPipeBlockingINTEL => .Pipe,
            .OpWritePipeBlockingINTEL => .Pipe,
            .OpFPGARegINTEL => .Reserved,
            .OpRayQueryGetRayTMinKHR => .Reserved,
            .OpRayQueryGetRayFlagsKHR => .Reserved,
            .OpRayQueryGetIntersectionTKHR => .Reserved,
            .OpRayQueryGetIntersectionInstanceCustomIndexKHR => .Reserved,
            .OpRayQueryGetIntersectionInstanceIdKHR => .Reserved,
            .OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR => .Reserved,
            .OpRayQueryGetIntersectionGeometryIndexKHR => .Reserved,
            .OpRayQueryGetIntersectionPrimitiveIndexKHR => .Reserved,
            .OpRayQueryGetIntersectionBarycentricsKHR => .Reserved,
            .OpRayQueryGetIntersectionFrontFaceKHR => .Reserved,
            .OpRayQueryGetIntersectionCandidateAABBOpaqueKHR => .Reserved,
            .OpRayQueryGetIntersectionObjectRayDirectionKHR => .Reserved,
            .OpRayQueryGetIntersectionObjectRayOriginKHR => .Reserved,
            .OpRayQueryGetWorldRayDirectionKHR => .Reserved,
            .OpRayQueryGetWorldRayOriginKHR => .Reserved,
            .OpRayQueryGetIntersectionObjectToWorldKHR => .Reserved,
            .OpRayQueryGetIntersectionWorldToObjectKHR => .Reserved,
            .OpAtomicFAddEXT => .Atomic,
            .OpTypeBufferSurfaceINTEL => .TypeDeclaration,
            .OpTypeStructContinuedINTEL => .TypeDeclaration,
            .OpConstantCompositeContinuedINTEL => .ConstantCreation,
            .OpSpecConstantCompositeContinuedINTEL => .ConstantCreation,
            .OpCompositeConstructContinuedINTEL => .Composite,
            .OpConvertFToBF16INTEL => .Conversion,
            .OpConvertBF16ToFINTEL => .Conversion,
            .OpControlBarrierArriveINTEL => .Barrier,
            .OpControlBarrierWaitINTEL => .Barrier,
            .OpGroupIMulKHR => .Group,
            .OpGroupFMulKHR => .Group,
            .OpGroupBitwiseAndKHR => .Group,
            .OpGroupBitwiseOrKHR => .Group,
            .OpGroupBitwiseXorKHR => .Group,
            .OpGroupLogicalAndKHR => .Group,
            .OpGroupLogicalOrKHR => .Group,
            .OpGroupLogicalXorKHR => .Group,
            .OpMaskedGatherINTEL => .Memory,
            .OpMaskedScatterINTEL => .Memory,
        };
    }
}
```
嗯，我现在要总结这段Zig代码的思维模型。首先，这段代码看起来像是定义了一个Opcode的枚举类型，每个枚举值对应一个操作码，用u16类型表示。然后，每个操作码可能有不同的操作数结构，用Operands函数根据不同的操作码返回对应的结构体类型。此外，还有一个class函数，将每个操作码分类到不同的类别，比如Miscellaneous、Debug、TypeDeclaration等等。

首先，我需要理解这段代码的整体结构。Opcode枚举列出了所有的操作码，每个操作码都有一个对应的数值。接下来，Operands函数通过switch语句，根据不同的Opcode返回不同的结构体类型，这些结构体描述了该操作码需要的参数。例如，OpNop没有操作数，返回void，而OpUndef需要id_result_type和id_result两个参数。

然后，class函数将每个操作码分配到不同的类别中，比如OpNop属于Miscellaneous，OpSourceContinued属于Debug。这有助于对操作码进行分类管理，可能在后续的处理中根据类别进行不同的操作。

接下来，我需要确认这些结构体中的字段是否与SPIR-V或其他相关标准中的操作码定义一致。例如，OpMemoryModel需要addressing_model和memory_model两个参数，这在SPIR-V规范中确实如此。另外，像OpTypeInt需要width和signedness，这也是符合规范的。

我还注意到，有些操作码的Operands结构体中有可选参数，比如OpSource中的file和source字段是可选的，通过?IdRef = null和?LiteralString = null表示。这说明这些参数在某些情况下可能不存在，需要处理为可选。

在class函数中，每个操作码被分类到不同的功能类别，比如ControlFlow、Memory、Atomic等。这有助于在编译器或解析器中根据类别进行优化或验证。例如，控制流类别的操作码可能在基本块的处理中有特殊规则。

另外，代码的最后部分有一些pub const定义，比如OpSDotKHR = Opcode.OpSDot，这可能是为了兼容不同扩展或版本的别名。例如，OpReportIntersectionNV可能指向OpReportIntersectionKHR，说明NV扩展和KHR扩展有部分操作码是相同的，通过别名来简化代码。

可能的问题点包括：某些操作码的分类是否正确？例如，OpDemoteToHelperInvocation被归类为ControlFlow，而OpIsHelperInvocationEXT被归类为Reserved，这是否符合预期？需要参考SPIR-V或相关扩展的文档确认。

此外，Operands函数中的结构体字段命名是否清晰？例如，OpGroupNonUniformIAdd中的clustersize参数是否有默认值？代码中使用了?IdRef = null表示可选参数，这在Zig中是允许的，但需要确保后续处理时正确处理这些可选参数。

总结来说，这段代码定义了一个完整的操作码枚举，每个操作码有对应的操作数结构和分类，可能是用于解析或生成SPIR-V字节码的工具。需要确保每个操作码的结构和分类与官方规范一致，同时处理可选参数和别名的情况。
================================================
这段代码定义了一个Zig语言中的枚举类型`Opcode`，用于表示SPIR-V（一种中间语言）的操作指令。其核心思维模型如下：

---

### **1. 操作码定义**
- **枚举结构**：`Opcode`枚举列出了所有SPIR-V支持的操作指令（如`OpNop`、`OpUndef`等），每个操作码对应一个`u16`类型的数值。
- **扩展支持**：包含核心SPIR-V指令及多个扩展（如`KHR`、`NV`、`AMD`、`INTEL`等）的特定操作码（如`OpTraceRayKHR`、`OpHitObjectRecordHitNV`）。

---

### **2. 操作数结构**
通过`Operands`函数，**每个操作码关联一个操作数结构体**，描述该指令所需的参数：
- **基础类型**：如`OpNop`无操作数（`void`），`OpUndef`需要结果类型和结果ID。
- **复杂结构**：如`OpImageSampleImplicitLod`包含结果类型、结果ID、采样图像、坐标等参数。
- **可选参数**：使用`?T = null`表示可选字段（如`OpSource`的`file`和`source`）。
- **动态数组**：如`OpSwitch`的`target`字段是`PairLiteralIntegerIdRef`的切片，表示多目标分支。

---

### **3. 分类系统**
通过`class`函数，**每个操作码被归类到功能类别**，例如：
- **控制流**（`ControlFlow`）：`OpBranch`、`OpReturn`。
- **内存操作**（`Memory`）：`OpLoad`、`OpStore`。
- **原子操作**（`Atomic`）：`OpAtomicIAdd`、`OpAtomicCompareExchange`。
- **图像处理**（`Image`）：`OpImageSampleImplicitLod`、`OpImageWrite`。
- **调试信息**（`Debug`）：`OpName`、`OpLine`。
- **扩展保留**（`Reserved`）：部分扩展指令（如`OpTraceRayKHR`）暂未归入核心类别。

---

### **4. 扩展与别名**
- **扩展操作码**：支持多种硬件扩展（如`KHR`光线追踪、`NV`着色器、`INTEL`子组操作）。
- **别名映射**：部分操作码通过别名兼容不同扩展（如`OpReportIntersectionNV`指向`OpReportIntersectionKHR`）。

---

### **5. 设计意图**
- **代码生成**：用于生成或解析SPIR-V字节码的工具，根据操作码的操作数结构序列化/反序列化指令。
- **静态验证**：通过分类系统，可在编译时检查指令的合法性（如控制流指令是否在正确上下文中使用）。
- **扩展兼容**：通过别名和分类，灵活支持不同厂商的SPIR-V扩展。

---

### **6. 关键实现细节**
- **类型安全**：使用Zig的编译时特性（`comptime`）确保操作数结构体与操作码严格匹配。
- **可选参数处理**：通过`?T`类型和默认值`null`处理可选操作数字段。
- **模式匹配**：通过`switch`语句实现操作码到操作数结构体的映射，保证全覆盖。

---

### **总结**
这段代码是SPIR-V指令集的Zig语言实现，通过枚举、操作数结构体和分类系统，实现了对SPIR-V指令的静态描述和动态处理支持。其核心目标是提供类型安全、可扩展的操作码定义，便于构建SPIR-V相关工具链（如编译器、反汇编器、优化器）。