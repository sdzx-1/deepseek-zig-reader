嗯，我现在要总结这个usage.c代码的主要函数流程。首先，我得通读一下代码，理解每个函数的作用以及它们之间的关系。代码看起来和Zephyr RTOS的线程使用统计相关，涉及到CPU和线程的运行时间统计，可能用于性能分析或调试。

首先，注意到有几个条件编译的宏，比如CONFIG_SCHED_THREAD_USAGE_ALL、CONFIG_SCHED_THREAD_USAGE_ANALYSIS等。这些宏的存在说明不同的功能模块可能根据配置开启或关闭。需要关注这些宏包裹的代码部分，因为它们会影响函数的行为。

接下来，全局变量usage_lock是一个自旋锁，用于保护共享资源，比如当前CPU的使用统计信息。这说明在多核或并发环境中，这些统计数据的访问需要同步，避免竞态条件。

函数usage_now()用于获取当前的时间点，可能是周期计数器或者定时器的值。这里有一个条件编译，根据CONFIG_THREAD_RUNTIME_STATS_USE_TIMING_FUNCTIONS来决定使用哪种方式获取时间。返回值处理了一个边界情况，当now为0时返回1，这可能是因为0被用作停止标记。

然后是sched_cpu_update_usage和sched_thread_update_usage这两个函数，分别更新CPU和线程的使用时间统计。在启用CONFIG_SCHED_THREAD_USAGE_ALL时，前者会被调用，否则被定义为空操作。这些函数将周期数加到总时间中，如果启用了分析功能，还会更新当前周期和最长周期等统计信息。

接下来是z_sched_usage_start和z_sched_usage_stop函数。z_sched_usage_start在调度开始时记录当前时间（usage0），并且在分析模式下会增加窗口计数并重置当前周期。z_sched_usage_stop则计算从usage0到当前的时间差，更新线程和CPU的统计，然后将usage0置零，表示停止统计。这里使用了自旋锁来保证原子操作。

对于收集CPU和线程统计信息的函数，比如z_sched_cpu_usage和z_sched_thread_usage，它们会先获取锁，然后根据需要更新当前正在运行的线程或CPU的统计信息，最后将数据复制到提供的结构体中。这里需要注意当前CPU是否正在统计，如果是，则需要先更新统计再获取最新数据。

另外，k_thread_runtime_stats_enable和disable函数用于启用或禁用特定线程的统计跟踪。启用时会设置track_usage标志，并初始化相关计数器；禁用时则停止跟踪，并可能更新最后一次的周期数。

还有系统级的统计开启和关闭函数k_sys_runtime_stats_enable和disable，这些函数会遍历所有CPU，启用或禁用它们的统计跟踪，并在禁用时更新最后的统计信息。

最后，涉及对象核心统计的部分，比如z_thread_stats_query和z_cpu_stats_query，这些函数通过容器宏获取对应的线程或CPU结构，并调用之前的统计函数来填充数据。重置统计的函数会清零相关计数器，并在需要时更新当前运行的线程的统计。

总结下来，主要流程涉及在调度开始和结束时记录时间差，更新对应的线程和CPU统计信息，同时通过锁机制保证数据的一致性。不同的配置选项允许开启更详细的统计功能，如最长运行时间、平均值等。此外，用户可以通过API启用或禁用统计，以及查询和重置统计信息。
================================================
该代码实现了Zephyr RTOS中线程和CPU运行时间统计的功能，主要函数流程如下：

---

### **核心函数流程**
1. **时间获取 (`usage_now`)**  
   - 根据配置选择`timing_counter_get()`或`k_cycle_get_32()`获取当前时间点。
   - 处理边界值：返回值为0时替换为1（0表示统计已停止）。

2. **统计更新**  
   - **CPU统计更新 (`sched_cpu_update_usage`)**  
     - 若开启`CONFIG_SCHED_THREAD_USAGE_ALL`且非空闲线程运行时，累加总周期数；若开启分析功能，更新当前周期和最长周期，空闲线程重置当前周期。
   - **线程统计更新 (`sched_thread_update_usage`)**  
     - 累加总周期数；若开启分析功能，更新当前周期和最长周期。

3. **调度统计启停**  
   - **启动统计 (`z_sched_usage_start`)**  
     - 记录当前时间到`_current_cpu->usage0`。
     - 若开启分析功能，增加统计窗口计数并重置线程的当前周期。
   - **停止统计 (`z_sched_usage_stop`)**  
     - 计算时间差，更新当前线程和CPU的统计，并将`usage0`置零。

4. **统计查询**  
   - **CPU统计 (`z_sched_cpu_usage`)**  
     - 若查询当前CPU，先更新其线程和CPU的统计，再返回总周期、空闲周期、峰值/平均周期（若开启分析）。
   - **线程统计 (`z_sched_thread_usage`)**  
     - 若查询当前运行线程，先更新其统计，再返回总周期、峰值/平均周期（若开启分析）。

5. **统计控制**  
   - **启用/禁用线程统计 (`k_thread_runtime_stats_enable/disable`)**  
     - 设置`track_usage`标志，更新窗口计数或停止时最后一次统计。
   - **全局启用/禁用统计 (`k_sys_runtime_stats_enable/disable`)**  
     - 遍历所有CPU，开启/关闭跟踪，禁用时同步最终统计。

6. **对象核心统计接口**  
   - **线程/CPU统计查询 (`z_thread_stats_query`, `z_cpu_stats_query`)**  
     - 通过容器宏获取对象，调用对应的统计函数。
   - **统计重置 (`z_thread_stats_reset`)**  
     - 清零总周期、峰值等字段，若线程正在运行则更新当前CPU统计。

---

### **关键机制**
- **同步控制**：通过自旋锁`usage_lock`保护共享数据（如`usage0`、统计结构），确保多核/多线程环境下的数据一致性。
- **条件编译**：根据配置（如`CONFIG_SCHED_THREAD_USAGE_ANALYSIS`）动态启用高级统计功能（峰值、平均值等）。
- **实时更新**：在查询统计时，若目标为当前运行线程或CPU，会先更新统计再返回结果，保证数据实时性。

---

### **功能总结**
- **基础统计**：记录线程和CPU的总运行时间。
- **高级分析**（可选）：跟踪最长单次运行时间、当前周期、平均周期。
- **灵活控制**：支持按线程或全局启用/禁用统计，提供统计重置接口。
- **多核支持**：遍历所有CPU进行全局操作，适配多核场景。