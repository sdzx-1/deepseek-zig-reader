graph TD
    A[开始] --> B[解析参数和源位置]
    B --> C[解析左右操作数]
    C --> D[获取操作数类型]
    D --> E[检查向量化操作数]
    E --> F{确定目标类型}
    F -->|shl_with_overflow| G[使用左操作数类型]
    F -->|其他操作| H[解析共同类型]
    G --> I[确定右操作数目标类型]
    H --> I
    I --> J[强制转换操作数类型]
    J --> K[检查目标类型是否为整数]
    K -->|否| L[返回类型错误]
    K -->|是| M[尝试解析常量值]
    M --> N{根据操作类型分支}
    N -->|add_with_overflow| O[处理加法的特殊情况]
    N -->|sub_with_overflow| P[处理减法的特殊情况]
    N -->|mul_with_overflow| Q[处理乘法的特殊情况]
    N -->|shl_with_overflow| R[处理左移的特殊情况]
    O --> S{存在零操作数?}
    S -->|是| T[直接返回结果和零溢出位]
    S -->|否| U{存在未定义值?}
    U -->|是| V[返回未定义结果]
    U -->|否| W[计算加法溢出结果]
    P --> X{右操作数是零?}
    X -->|是| Y[直接返回左操作数和零溢出位]
    X -->|否| Z{存在未定义值?}
    Z -->|是| AA[返回未定义结果]
    Z -->|否| AB[计算减法溢出结果]
    Q --> AC{存在零或一操作数?}
    AC -->|是| AD[直接返回对应结果]
    AC -->|否| AE{存在未定义值?}
    AE -->|是| AF[返回未定义结果]
    AE -->|否| AG[计算乘法溢出结果]
    R --> AH{左或右操作数为零?}
    AH -->|是| AI[直接返回左操作数和零溢出位]
    AH -->|否| AJ{存在未定义值?}
    AJ -->|是| AK[返回未定义结果]
    AJ -->|否| AL[计算左移溢出结果]
    W --> AM[构造结果元组]
    AB --> AM
    AG --> AM
    AL --> AM
    V --> AM
    Y --> AM
    T --> AM
    AD --> AM
    AI --> AM
    AM --> AN{结果是否已实例化?}
    AN -->|是| AO[直接返回常量结果]
    AN -->|否| AP[生成运行时指令]
    L --> AQ[结束]
    AO --> AQ
    AP --> AQ
